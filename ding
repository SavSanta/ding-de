#!/bin/sh
# the next line restarts using wish \
LC_CTYPE=de_DE.UTF-8; export LC_CTYPE; exec wish "$0" "$@"

# This is "ding", 
#  * A dictionary lookup program,
#  * DIctionary Nice Grep,
#  * A Front-End to [ae]grep, ispell, dict, ...
#  * Ding {n} :: thing
#
# Copyright (c) Frank Richter <frank.richter@hrz.tu-chemnitz.de> 1999 - 2016
# GNU public license
# Ding comes with ABSOLUTELY NO WARRANTY.
# 

set pinfo(pname)    {Ding: Dictionary Lookup}
set pinfo(version)  {1.8.1}
set pinfo(homepage) {http://www-user.tu-chemnitz.de/~fri/ding/}

set ding_usage(en) \
"    word\tStart seaching this word
   -x   or --selection\tStart searching for selected word (X selection)
   -m   or --mini\tStart with minimal size (search form only)\n
   -r   or --remote\tStart search in an already running program
   -R   or --remote-new\tStart search in an already running program
                       \tor start a new program\n
           --noconf\tDo not save preferences
   -D # or --debug #\tStart with debug output, # = number (1..15)\n
These options may be combined, such as:
   $argv0 -R -x\tStart searching for selected word in an already
   \trunning program or start a new program\n"

set ding_usage(de) "
   Suchwort\tStarte Suche nach Suchwort
   -x   oder --selection\tStarte Suche mit markiertem Text
   -m   oder --mini\tStarte in Mini-Größe (nur Sucheingabe)\n
   -r   oder --remote\tStarte Suche in bereits laufendem Programm
   -R   oder --remote-new\tStarte Suche in bereits laufendem Programm
   \toder starte neues Programm\n
             --noconf\tKein Speichern der Einstellungen
   -D # oder --debug #\tDebug-Ausschriften, # = Zahl (1..15)\n
Die Optionen können natürlich kombiniert werden, z.B.:
   $argv0 -R -x\tStarte Suche nach markiertem Wort in bereits
   \tlaufendem Programm oder starte neues Programm\n"

proc Usage {} {
    global pinfo argv0 env ding_usage
    puts "\n$pinfo(pname) version $pinfo(version)"

    if {[info exists env(LANG)] && [info exists ding_usage([string range $env(LANG) 0 1])]} {
        puts "Usage: $argv0 \[Optionen\] \[Suchwort\]"
        puts $ding_usage([string range $env(LANG) 0 1])
        puts "Siehe WWW-Homepage: $pinfo(homepage)"
    } else {
        puts "Usage: $argv0 \[options\] \[word\]"
        puts $ding_usage(en)
        puts "See WWW homepage: $pinfo(homepage)"
    }
}

if { ![info exists tk_version] } {
    Usage
    exit
}

if {$tk_version < 8.3} {
    tk_messageBox -type ok -icon error -message {
Sorry, wish version >= 8.3 is required.  Try to install a newer Tk version.

Die Version von Tcl/Tk ist zu alt, bitte Version 8.3 oder höher installieren.

Exiting ...}
    exit
}

set param(isunix) [expr {$tcl_platform(platform) == {unix}}]
set param(iswin)  [expr {$tcl_platform(platform) == {windows}}]

# Config options you may want to change:
# Startup file
set param(rcfile) [expr {$param(isunix) == 1 ? "$env(HOME)/.dingrc" : "[file dirname argv0]/dingrc.tcl"}]
set param(noticefile) [expr {$param(isunix) == 1 ? "$env(HOME)/.dingnotice.txt" : "[file dirname argv0]/dingntc.txt"}]

# The default search methods
# The provided German-English dictionary:
set default_searchmeth(0,name) {Dictionary}
set default_searchmeth(0,grepcmds) {agrep egrep internal_search}
set default_searchmeth(0,dictfile) [expr {$param(isunix) ?  "/usr/share/dict/de-en.txt" : "[file dirname argv0]/de-en.txt"}]
set default_searchmeth(0,separator) { :: }
set default_searchmeth(0,language1) {Deutsch}
set default_searchmeth(0,language2) {English}
set default_searchmeth(0,foldedresult) 1

# spell checker
set default_searchmeth(1,name) {Spell check}
set default_searchmeth(1,grepcmds) {hunspell ispell aspell}
set default_searchmeth(1,language1)  "English spell check"
set default_searchmeth(1,grepopts)  "-B -d english -a"
# --encoding utf-8

# spell checker
set default_searchmeth(2,name) {Rechtschreibung}
set default_searchmeth(2,grepcmds) {hunspell ispell aspell}
set default_searchmeth(2,language1)  "Deutsche Rechtschreibprüfung"
set default_searchmeth(2,grepopts)  "-B -d german -a"

# dict - english ditionary
set default_searchmeth(3,name) {English}
set default_searchmeth(3,grepcmds) {dict}
set default_searchmeth(3,language1)  "English Dictionary"

# Fortunes
set default_searchmeth(4,name) {Epigram}
set default_searchmeth(4,grepcmds) {/usr/bin/fortune}
set default_searchmeth(4,language1)  "Random English adage/epigram"
set default_searchmeth(4,grepopts)  ""
set default_searchmeth(4,minlength)  0

# check for these search commands
set default_grepcmds(agrep) "-h"
set default_grepcmds(egrep) "-h"
set default_grepcmds(dict) ""
set default_grepcmds(hunspell) "-B -S -a"
set default_grepcmds(ispell) "-B -S -a"
set default_grepcmds(aspell) "-B -S -a"
set default_grepcmds(/usr/bin/fortune) ""
set default_grepcmds(internal_search) ""

set default_searchopts(minlength)    2
set default_searchopts(maxlength)   30
set default_searchopts(maxresults) 200
set default_searchopts(shapedresult) 1
set default_searchopts(foldedresult) 0

set default(maxhistory)    50
set default(autosave)       1
set default(hilite)         1
set default(raise)          0 
set default(params_as_menu) 0
set default(show_menu)      1
set default(umlaut_buttons) 0
set default(show_result)    1
set default(show_status)    1
set default(bcolor) [expr {$param(isunix) ? [. cget -background] : "#C0C0C0"}]
set default(fcolor)     "#000000"

set default(showBalloons)   1
set default(balloonDelay)   800
array set balloonHelp      {}
set gparam(balloonBackground)  LightGoldenrodYellow
set default(autosearch)     0
set default(autosearchDelay)   1000
# set default(automin)        0
set default(autominDelay)   8000
set default(search_prop)    0
set default(win_prop)       0

if {$param(isunix)} {
    # set lfont "-*-Helvetica-Medium-R-Normal--*-100-*-*-*-*-*-*"
    # set bfont "-*-Helvetica-Bold-R-Normal--*-100-*-*-*-*-*-*"
    # set sfont "-*-Helvetica-Medium-R-Normal--*-100-*-*-*-*-*-*"
    # set default_tfont "-*-Courier-Medium-R-Normal--*-120-*-*-*-*-*-*"
    set default(lfont)        {helvetica 12 normal}
    set param(bfont)          {helvetica 12 bold}
    set param(ifont)          {helvetica 12 "" italic}
    set param(sfont)          {helvetica 10 normal}
    set default(tfont)        {fixed 14 normal}
    set default(ipafont)      {lucidatypewriter 14 normal}

    # Font selection
    # show all avail. font families
    # set param(tfonts) {}
    # or show only this subset:
    set param(tfonts) {courier fixed lucida helvetica times terminal bitstream* dejavu* liberation* lucida* luxi* nimbus* urw*}
} else {
    set default(lfont) {Arial 10 normal}
    set param(bfont)   {Arial 10 bold}
    set param(ifont)   {Arial 10 "" italic}
    set param(sfont)   {Arial 8 normal}
    set default(tfont) {Arial 10 normal}
    # set default(tfont) {Courier 10 normal}

    # Font selection
    # show all avail. font families
    set param(tfonts) {}
    # or show only this subset:
    # set param(tfonts) {Arial System Times Courier Verdana}
}

set param(tfont) $default(tfont)
set param(lfont) $default(lfont)
set param(ipafont) $default(ipafont)

set opts(case)   0
set opts(word)   0
set opts(regex)  0
set opts(errors) 0

### don't change from here unless you know what you're doing .-)
# set defaults
set param(showBalloons)    $default(showBalloons)
set param(balloonDelay)    $default(balloonDelay)
set param(autosearch)      $default(autosearch)
set param(autosearchDelay) $default(autosearchDelay)
set param(autosearch_active)    0
set param(autosearch_onchage_active)    0
# set param(automin)         $default(automin)
set param(autominDelay)    $default(autominDelay)
set param(autosave)        $default(autosave)
set param(hilite)          $default(hilite)
set param(raise)           $default(raise)

set param(bcolor)           $default(bcolor)
set param(fcolor)           $default(fcolor)
set param(maxhistory)       $default(maxhistory)
set param(params_as_menu)   $default(params_as_menu)
set param(show_menu)        $default(show_menu)
set param(umlaut_buttons)   $default(umlaut_buttons)
set param(show_result)      $default(show_result)
set param(show_status)      $default(show_status)
set param(search_prop)      $default(search_prop)
set param(win_prop)         $default(win_prop)
set param(check_selection_active) 0

set curhistory 0
set inshistory 0
array set history_result {}
array set history_query {}
array set history_pos {}
array set history_fold {}

set pinfo(authormail) {frank.richter@hrz.tu-chemnitz.de}
set pinfo(author)     "Frank Richter <$pinfo(authormail)>"
set pinfo(copyright) "Copyright (c) 1999 - 2016 $pinfo(author)"

set proc(pid) -1
set proc(pipe) {}
set proc(processlist) {}
set lines {} 
set sigchld 0

# interface language settings
set languages(en) {English}
set languages(de) {Deutsch}
set default(language) {en}
set gparam(lang) $default(language)
set defaultcursor [. cget -cursor]

# Debug level 
# 1 - main functions   2 - trace    4 - external process 8 - util
set param(debug) 0
# set param(debug) 15

# correction of height for some window managers
set param(add_geom_height)  0


# English messages
set s(en)(file) "File"
set s(en)(newwin) "New window"
set s(en)(quit) "Quit"
set s(en)(save) "Save"
set s(en)(saveall) "Save all"
set s(en)(mail) "Send corrections"
set s(en)(options) "Preferences"
set s(en)(params) "Search options"
set s(en)(soptions) "Search preferences..."
set s(en)(general) "General preferences..."
set s(en)(saveopts) "Save preferences"
set s(en)(help) "Help"
set s(en)(khelp) "Keys"
set s(en)(abbhelp) "Abbreviations"
set s(en)(cmdline) "Start options"
set s(en)(about) "About"
set s(en)(ctl) "Ctrl"
set s(en)(shift) "Shift"
set s(en)(space) "Space"
set s(en)(up) "Up"
set s(en)(down) "Down"
set s(en)(noback) "No previous search results."
set s(en)(noforw) "No more search results."
set s(en)(query) "Search word:"
set s(en)(searchmeth) "Search methods"
set s(en)(configured) "Configured"
set s(en)(search) "Search"
set s(en)(searchhelp) "Click left: Start search method\nClick middle: Search in result"
set s(en)(clear) "Clear"
set s(en)(clearhelp) "Erase search word, also with Esc key"
set s(en)(minimize) "Minimize window"
set s(en)(normalsize) "Show full window"
set s(en)(word)(0) "full words"
set s(en)(word)(1) "partial search"
set s(en)(case)(0) "ignore case"
set s(en)(case)(1) "exact case"
set s(en)(errors) "errors"
set s(en)(error) "error"
set s(en)(closestmatch) "best match"
set s(en)(regex)(0) "simple search"
set s(en)(regex)(1) "reg. expression"
set s(en)(cmd) "Search with"
set s(en)(bbhistory) "Previous results"
set s(en)(bfhistory) "Next results"
set s(en)(bwords) "Search for full words\nor partial matches?"
set s(en)(bcase) "Search case insensitive or sensitive?"
set s(en)(berrors) "Try error correction?"
set s(en)(bregex) "Simple patterns with *\nor regular expressions?"
set s(en)(color) "Select color"
set s(en)(results) "results"
set s(en)(result) "result"
set s(en)(noresults) "No results for"
set s(en)(notfound) "Search word not found"
set s(en)(correct) "Correctly spelled, no suggestions"
set s(en)(suggestion) "Suggestions"
set s(en)(nosuggestion) "Spelling is wrong or unknown, no suggestions"
set s(en)(root) "word root"
set s(en)(searcho) "Set search options"
set s(en)(searchm) "Set search methods"
set s(en)(apply) "Apply"
set s(en)(default) "Default"
set s(en)(cancel) "Cancel"
set s(en)(dictfile) "Dictionary file"
set s(en)(nodictfile) "No Dictionary file found! See Preferences | Search prefences ..."
set s(en)(new)    "New"
set s(en)(edit)   "Change"
set s(en)(delete) "Delete"
set s(en)(hilite) "Highlight text in result window when mouse over"
set s(en)(raise)  "Bring window on top when search finished"
set s(en)(automin)  "Minimize window automatically"
set s(en)(autosave) "Save options whenever changed"
set s(en)(lang) "Language"
set s(en)(sep) "Separator"
set s(en)(maxresults) "Max. number of results"
set s(en)(minlength) "Min. length of search word"
set s(en)(maxlength) "Max. length of search word"
set s(en)(params_as_menu) "Show search parameters"
set s(en)(show_menu)      "Show menu bar"
set s(en)(show_menu_desc) "To bring menu back click with right mouse button"
set s(en)(hide_menu)      "Hide menu bar"
set s(en)(umlaut_buttons) "Show umlaut buttons"
set s(en)(show_result) "Show search form only "
set s(en)(show_status) "Show status line"
set s(en)(hide_status) "Hide status line"
set s(en)(fg) "Foreground color..."
set s(en)(bg) "Background color..."
set s(en)(change) "Swap"
set s(en)(maxhistory) "Remember how many results"
set s(en)(balloon) "Show balloon help"
set s(en)(after) "after"
set s(en)(ms) "msec"
set s(en)(autosearch) "Start searching automatically"
set s(en)(mailtitle) "Send e-mail to"
set s(en)(send) "Send e-mail"
set s(en)(notext) "No text for your e-mail?\nNo message sent."
set s(en)(nomail) "Please send your suggestions with a mail program to"
set s(en)(notice) "Write a notice"
set s(en)(attachnotice) "Include notices"
set s(en)(nosave) "No search results to save!"
set s(en)(tooshort) "Search word too short!"
set s(en)(toolong) "Search word too long!"
set s(en)(more) "(found more, max limit reached)"
set s(en)(tfont) "Result font"
set s(en)(lfont) "Other font"
set s(en)(larger_font) "Increase font size"
set s(en)(smaller_font) "Decrease font size"
set s(en)(default_font) "Default font size"
set s(en)(defaultdict) "De <-> En"
set s(en)(shaped) "Results shaped"
set s(en)(folded) "Results folded"
set s(en)(name) "Name"
set s(en)(grepcmd) "Search command"
set s(en)(grepopts) "Options"
set s(en)(noagrep) "The \"agrep\" command wasn't found on your system.
Some functions won't be available for searching.\n
As a recommendation - install agrep.
You'll find it in a special agrep package or within the Glimpse package.\n
We will use for now: "
set s(en)(changes_later) "Some changes will come into effect after program restart."
set s(en)(kill) "Search process was stopped."
set s(en)(nokill) "Couldn't stop search process."
set s(en)(namerequired) "Please give a name to this search method."
set s(en)(props) "Search behaviour"
set s(en)(change_props) "Change search behaviour"
set s(en)(onrequest) "Search on input / middle mouse button"
set s(en)(onmouseover) "Search on mouse over"
set s(en)(onselection) "Search on new text selection"
set s(en)(min_none) "Don't minimize window automatically"
set s(en)(min_focus_delay) "Minimize window delayed"
set s(en)(min_focus) "Minimize window when mouse out"
set s(en)(clipboard_copy_line) "Copy current line to clipboard"
set s(en)(clipboard_copy_all)  "Copy current result to clipboard"

# German messages
set s(de)(file) "Datei"
set s(de)(newwin) "Neues Fenster"
set s(de)(quit) "Beenden"
set s(de)(save) "Speichern"
set s(de)(saveall) "Alles speichern"
set s(de)(mail) "Korrektur senden"
set s(de)(options) "Einstellungen"
set s(de)(params) "Suchparameter"
set s(de)(soptions) "Suchmethoden..."
set s(de)(general) "Allgemein..."
set s(de)(saveopts) "Einstellungen speichern"
set s(de)(help) "Hilfe"
set s(de)(khelp) "Tastatur"
set s(de)(abbhelp) "Abkürzungen"
set s(de)(cmdline) "Startoptionen"
set s(de)(about) "Info"
set s(de)(ctl) "Strg"
set s(de)(shift) "Umschalt"
set s(de)(space) "Leer"
set s(de)(up) "Hoch"
set s(de)(down) "Runter"
set s(de)(noback) "Keine früheren Suchergebnisse."
set s(de)(noforw) "Keine weiteren Suchergebnisse."
set s(de)(query) "Suchwort:"
set s(de)(searchmeth) "Suchmethoden"
set s(de)(configured) "Eingestellte"
set s(de)(search) "Suche"
set s(de)(searchhelp) "Klick links: Suchmethode starten\nKlick mittel: Suche in Ergebnis"
set s(de)(clear) "Löschen"
set s(de)(clearhelp) "Lösche Suchwort, auch mit Esc-Taste"
set s(de)(minimize) "Fenster minimieren"
set s(de)(normalsize) "Volles Fenster anzeigen"
set s(de)(word)(0) "ganze Wörter"
set s(de)(word)(1) "Teilsuche"
set s(de)(case)(0) "Groß/klein egal"
set s(de)(case)(1) "Groß/klein exakt"
set s(de)(errors) "Fehler"
set s(de)(error) "Fehler"
set s(de)(closestmatch) "bis Treffer"
set s(de)(regex)(0) "einfache Suche"
set s(de)(regex)(1) "reg. Ausdrücke"
set s(de)(cmd) "Suche mit"
set s(de)(bbhistory) "Frühere Suchergebnisse"
set s(de)(bfhistory) "Weitere Suchergebnisse"
set s(de)(bwords) "Suche nach vollständigen Wörtern\noder Muster in Wörtern?"
set s(de)(bcase) "Unterscheidung Groß-/Kleinschreibweise?"
set s(de)(berrors) "Versuche Fehlerkorrektur?"
set s(de)(bregex) "Einfache Muster mit * oder\nkomplexe reguläre Ausdrücke?"
set s(de)(color) "Farbauswahl"
set s(de)(results) "Ergebnisse"
set s(de)(result) "Ergebnis"
set s(de)(noresults) "Kein Ergebnis für"
set s(de)(notfound) "Suchbegriff nicht gefunden"
set s(de)(correct) "Richtige Schreibweise, keine Vorschläge"
set s(de)(suggestion) "Vorschläge"
set s(de)(nosuggestion) "Falsche oder unbekannte Schreibweise, keine Vorschläge"
set s(de)(root) "Wortstamm"
set s(de)(searcho) "Suchmethoden einstellen"
set s(de)(searchm) "Suchmethoden festlegen"
set s(de)(apply) "Übernehmen"
set s(de)(default) "Standard"
set s(de)(cancel) "Abbrechen"
set s(de)(dictfile) "Wörterbuch-Datei"
set s(de)(nodictfile) "Keine Wörterbuch-Datei gefunden! Siehe Einstellungen | Suchmethoden"
set s(de)(new)    "Neu"
set s(de)(edit)   "Ändern"
set s(de)(delete) "Entfernen"
set s(de)(lang) "Sprache"
set s(de)(sep) "Trennzeichen"
set s(de)(maxresults) "Maximalanzahl von Ergebnissen"
set s(de)(minlength) "Minimale Länge des Suchwortes"
set s(de)(maxlength) "Maximale Länge des Suchwortes"
set s(de)(params_as_menu) "Suchparameter anzeigen"
set s(de)(show_menu)      "Menüleiste anzeigen"
set s(de)(show_menu_desc) "Menüleiste wiederherstellen mit rechter Maustaste"
set s(de)(hide_menu)      "Menüleiste verbergen"
set s(de)(umlaut_buttons) "Umlautknöpfe anzeigen"
set s(de)(show_result) "Nur Suchmaske anzeigen"
set s(de)(show_status) "Statuszeile anzeigen"
set s(de)(hide_status) "Statuszeile verbergen"
set s(de)(fg) "Vordergrundfarbe..."
set s(de)(bg) "Hintergrundfarbe..."
set s(de)(change) "Vertauschen"
set s(de)(maxhistory) "Merken wievieler Ergebnisse"
set s(de)(balloon) "Hilfen anzeigen"
set s(de)(after) "nach"
set s(de)(ms) "ms"
set s(de)(autosearch) "Suche automatisch beginnen"
set s(de)(automin)  "Fenster automatisch minimieren"
set s(de)(hilite) "Ergebniszeile unter Mauszeiger hervorheben"
set s(de)(raise)  "Fenster in Vordergrund heben, wenn Suche fertig"
set s(de)(autosave) "Einstellungen bei Änderung sofort speichern"
set s(de)(mailtitle) "Sende E-Mail an"
set s(de)(send) "E-Mail absenden"
set s(de)(notext) "Kein Text in der E-Mail?\nKeine Nachricht gesendet."
set s(de)(nomail) "Bitte senden Sie Ihre E-Mail mit einem Mail-Programm
an"
set s(de)(notice) "Notiz schreiben"
set s(de)(attachnotice) "Notizen einlesen"
set s(de)(nosave) "Noch keine Suchergebnisse zum Abspeichern."
set s(de)(tooshort) "Suchbegriff zu kurz!"
set s(de)(toolong) "Suchbegriff zu lang!"
set s(de)(more) "(weitere vorhanden, Suche abgebrochen)"
set s(de)(tfont) "Schriftart für Resultat"
set s(de)(lfont) "Sonstige Schriftart"
set s(de)(larger_font) "Schrift vergrößern"
set s(de)(smaller_font) "Schrift verkleinern"
set s(de)(default_font) "Standard-Schriftgröße"
set s(de)(defaultdict) "De <-> En"
set s(de)(shaped) "Resultate farblich abgesetzt"
set s(de)(folded) "Resultate eingeklappt"
set s(de)(name) "Name"
set s(de)(grepcmd) "Such-Kommando"
set s(de)(grepopts) "Optionen"
set s(de)(noagrep) "Das Kommando \"agrep\" wurde in Ihrem System nicht gefunden.
Dadurch stehen einige Funktionen nicht zur Verfügung.\n
Empfehlung: agrep installieren!
Sie finden es in einem speziellen agrep-Paket oder im glimpse-Paket.\n
Jetzt wird verwendet: "
set s(de)(changes_later) "Einige Änderungen werden erst nach Neustart des Programmes sichtbar."
set s(de)(kill) "Suchvorgang wurde gestoppt."
set s(de)(nokill) "Suchvorgang konnte nicht gestoppt werden."
set s(de)(namerequired) "Bitte dieser Suchmethode einen Namen geben."
set s(de)(props) "Suchverhalten"
set s(de)(change_props) "Ändere Suchverhalten"
set s(de)(onrequest) "Suche erst nach Eingabe/mittl. Maustaste"
set s(de)(onmouseover) "Suche sobald Maus über Fenster"
set s(de)(onselection) "Suche sofort bei neuer Textauswahl"
set s(de)(min_none) "Fenster nicht automatisch minimieren"
set s(de)(min_focus_delay) "Fenster verzögert minimieren"
set s(de)(min_focus) "Fenster sofort minimieren, wenn Fokus woanders"
set s(de)(clipboard_copy_line) "Aktuelle Zeile in Zwischenablage"
set s(de)(clipboard_copy_all)  "Suchergebnis in Zwischenablage"

# Debug procedure
proc debug {level s} {
    # levels:
    # 1 - main function tracing (begin, parameters, end)
    # 2 - minor function tracing
    # 4 - communication with external programs
    # 8 - others ...
    global param
    if [expr $param(debug) & $level] { 
        set time [clock format [clock seconds] -format "%T"]
        puts stderr "$time $level $s"
    }
} 

if {$param(iswin) == 1} {
    set l [registry get {HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\Language} Default]
    if {$l == "0407"} {     # DE
        set default(language) "de"
        set gparam(lang) "de"
    }
} elseif {$param(isunix) == 1} {
    # if Shell variable LANG set AND we've defined this language, 
    # set this as default
    if [info exists env(LANG)] {
        foreach l [array names languages] {
            if [string match "$l*" $env(LANG)] {
                set default(language) $l
                set gparam(lang) $l
                break
            }
        }
        # check for UTF-8, as in "de_DE.UTF-8"
        regsub {\.UTF-8} $env(LANG) {} env(LANG)
        # puts stderr "LANG is $env(LANG)"
    }
}

proc errorBox {msg} {
    tk_messageBox -message $msg -type ok -icon error
}

# for flag -remote: send a command to a running ding
proc remote {query} {
    debug 1 "remote $query"

    # my own application name
    regsub { .*} [tk appname] {} myname
    debug 8 "  myname = $myname"

    # find an alway running application ...
    foreach i [lsort [winfo interps]] {
        if [string match "${myname}*" $i] {
            debug 4 " send $i querydictsearch $query"
            set result [catch [list send $i [concat querydictsearch [list $query]]] msg]
            if {$result != 0} {
                # error - try next
                debug 4 " returns: $result"
            } else {
                # ok
                return 0
            }
        }
    }
    # error
    return 1
}

############### main

# check command line parameters
set mini 0
set gparam(noconf) 0
set remote 0
set new 0
set query {}
set last_selection {}

for {set a 0} {$a < $argc} {incr a} {
    set arg [lindex $argv $a]
    if {([string compare $arg "--help"] == 0) || 
        ([string compare $arg "-h"] == 0)} {
        Usage
        exit
    } elseif {([string compare $arg "--remote"] == 0) || 
        ([string compare $arg "-r"] == 0)} {
        set remote 1
    } elseif {([string compare $arg "--remote-new"] == 0) ||
              ([string compare $arg {-R}] == 0)} {
        set remote 1
        set new 1
    } elseif {([string compare $arg {--selection}] == 0) ||
              ([string compare $arg {-x}] == 0)} {
        # first search with current X selection
        if {$param(isunix)} {
            catch {set q [selection get]}
        } else {
            catch {set q [selection get -selection CLIPBOARD]}
        }
        if {[info exists q] && [string length $q] > 0} {
            if {$opts(regex) == 0} {         # replace regex characters
                regsub -all {[*|\]\[]} $q {} q
            }
            if {[string length $q] > 0} {
                set query $q
                set last_selection $q
            }
        }
    } elseif {([string compare $arg "--mini"] == 0) ||
              ([string compare $arg "-m"] == 0)} {
        set mini 1
    } elseif {([string compare $arg "--noconf"] == 0)} {
        set gparam(noconf) 1
        set param(autosave) 0
    } elseif {([string compare $arg "--debug"] == 0) ||
              ([string compare $arg "-D"] == 0)} {
        incr a
        if {$a < $argc} {
            set param(debug) [lindex $argv $a]
        }
    } elseif {! [string match {-*} $arg]} {
        # argument is a search query
        set query "$query $arg"
    }
}

debug 1 "end of argument parsing: remote = $remote new = $new, query = $query, mini = $mini"
if {$remote} {
    # send a command to a running ding
    set ret 1
    if [string length $query] {
        set ret [remote $query]
    }
    debug 1 "remote exit $ret"
    # if send was ok or no new window -> exit
    if {($ret == 0) || (! $new)} {
        exit $ret
    }
}

# read user's config file if existing
if [file readable $param(rcfile)] {
    set err [catch "source $param(rcfile)" errmsg]
    if $err {
        errorBox "Error in config file $param(rcfile):\n$errmsg"
        exit
    }
}

# check if we have tkTable extension
if {0} {
if {[string match {} [info commands table]] && 
    [catch {package require Tktable} err] &&
    [catch {load [file join [pwd] Tktable[info sharedlibextension]]} err]} {
    debug 1 "No tkTable: $err"
    set hastable 0
} else {
    debug 1 "Tktable v[package provide Tktable] loaded"
    set hastable 1
}
}

array set avail_cmds {}

proc cmd_avail {cmd} {
    global env param avail_cmds

    debug 2 "cmd_avail $cmd"
    if [string match "internal_*" $cmd] {
        return 1
    } elseif {[llength [array get avail_cmds $cmd]] > 1} {
        # found earlier
        return 1
    } elseif {$param(isunix)} {
        if {[string index $cmd 0] == "/" && [file isfile $cmd] && [file executable $cmd]} {
            debug 8 "Found $cmd"
            set avail_cmds($cmd) 1
            return 1
        }
        if {[llength [array get env PATH]] < 1} {
            return 0
        }
        foreach p [split $env(PATH) :] {
            if {[file isfile "$p/$cmd"] && [file executable "$p/$cmd"]} {
                debug 8 "Found $p/$cmd"
                set avail_cmds($cmd) 1
                return 1
            }
        }
    } else {
        if {[file executable $cmd] || [file executable "$cmd.exe"]} {
            # errorBox "Found $cmd.exe"
            return 1
        }
    }
    return 0
}

# check available search commands
set gparam(grepcmd) {}
foreach c [array names default_grepcmds] {
    if [cmd_avail $c] {
        if {$gparam(grepcmd) == ""} {       # default search cmd
            set gparam(grepcmd) $c
        }
        set grepcmds($c) "$default_grepcmds($c)"
    }
}

set cmds 0

# 1.0 options - no prog_version used
# do backward compatibility

if { ! [info exists ding_version]} {
    # 1.0 options - no prog_version used
    # or new user
    set searchmeth(0,name) [set s(en)(defaultdict)]
    set searchmeth(0,type) 0
    foreach i [array names default_searchopts] {
        set searchmeth(0,$i) $default_searchopts($i)
    }
    if [info exists dictfile] {
        set searchmeth(0,dictfile) $dictfile
    } else {
        set searchmeth(0,dictfile) $default_searchmeth(0,dictfile)
    }
    set searchmeth(0,dictfiles) [glob -nocomplain $searchmeth(0,dictfile)]
    if [info exists language1] {
        set searchmeth(0,language1) $language1
    } else {
        set searchmeth(0,language1) $default_searchmeth(0,language1)
    }
    if [info exists language2] {
        set searchmeth(0,language2) $language2
    } else {
        set searchmeth(0,language2) $default_searchmeth(0,language2)
    }
    if [info exists separator] {
        set searchmeth(0,separator) $separator
    } elseif [info exists default_searchmeth(0,separator)] {
        set searchmeth(0,separator) $default_searchmeth(0,separator)
    } else {
        set searchmeth(0,separator) {}
    }
    if [info exists maxlength] {
        set searchmeth(0,maxlength) $maxlength
    } elseif [info exists default_searchmeth(0,maxlength)] {
        set searchmeth(0,maxlength) $default_searchmeth(0,maxlength)
    }
    if [info exists maxresults] {
        set searchmeth(0,maxresults) $maxresults
    } elseif [info exists default_searchmeth(0,maxresults)] {
        set searchmeth(0,maxresults) $default_searchmeth(0,maxresults)
    }
    if [info exists minlength] {
        set searchmeth(0,minlength) $minlength
    } elseif [info exists default_searchmeth(0,minlength)] {
        set searchmeth(0,minlength) $default_searchmeth(0,minlength)
    }
    set searchmeth(0,shapedresult) $default_searchopts(shapedresult)
    set searchmeth(0,foldedresult) $default_searchmeth(0,foldedresult)
    if [info exists grepcmd] {
        set searchmeth(0,grepcmd) $grepcmd
    } else {
        # evtl. spezifisches grep cmd
        foreach c $default_searchmeth(0,grepcmds) {
            if [info exists grepcmds($c)] {
                set searchmeth(0,grepcmd) $c
                break
            }
        }
    }
    if [info exists grepopts] {
        set searchmeth(0,grepopts) $grepopts
    } else {
        set searchmeth(0,grepopts) "$grepcmds($searchmeth(0,grepcmd))"
    }

    set searchmeth(0,avail) 1
    set searchmpos 0

    # Enable other available search methods
    for {set m 1} {[info exists default_searchmeth($m,name)]} {incr m} {
        foreach c $default_searchmeth($m,grepcmds) {
            if [info exists grepcmds($c)] {
                set searchmeth($m,name) $default_searchmeth($m,name)
                set searchmeth($m,type) $m
                set searchmeth($m,grepcmd) $c
                if [info exists default_searchmeth($m,grepopts)] {
                    set searchmeth($m,grepopts) $default_searchmeth($m,grepopts)
                } else {
                    set searchmeth($m,grepopts) $grepcmds($c)
                }
                foreach i [array names default_searchopts] {
                    set searchmeth($m,$i) $default_searchopts($i)
                }
                if [info exists default_searchmeth($m,dictfile)] {
                    set searchmeth($m,dictfile) $default_searchmeth($m,dictfile)
                } else {
                    set searchmeth($m,dictfile) {}
                }
                set searchmeth($m,dictfiles) [glob -nocomplain $searchmeth($m,dictfile)]
                if [info exists default_searchmeth($m,language1)] {
                    set searchmeth($m,language1) $default_searchmeth($m,language1)
                } else {
                    set searchmeth($m,language1) {}
                }
                if [info exists default_searchmeth($m,language2)] {
                    set searchmeth($m,language2) $default_searchmeth($m,language2)
                } else {
                    set searchmeth($m,language2) {}
                }
                if [info exists default_searchmeth($m,separator)] {
                    set searchmeth($m,separator) $default_searchmeth($m,separator)
                } else {
                    set searchmeth($m,separator) {}
                }
                if [info exists default_searchmeth($m,maxlength)] {
                    set searchmeth($m,maxlength) $default_searchmeth($m,maxlength)
                }
                if [info exists default_searchmeth($m,maxresults)] {
                    set searchmeth($m,maxresults) $default_searchmeth($m,maxresults)
                }
                if [info exists default_searchmeth($m,minlength)] {
                    set searchmeth($m,minlength) $default_searchmeth($m,minlength)
                }
                if [info exists default_searchmeth($m,shapedresult)] {
                    set searchmeth($m,shapedresult) $default_searchmeth($m,shapedresult)
                }
                if [info exists default_searchmeth($m,foldedresult)] {
                    set searchmeth($m,foldedresult) $default_searchmeth($m,foldedresult)
                }
                set searchmeth($m,avail) 1
                lappend searchmpos $m
    
                break
            }
        }
    }

    if [info exists maxhistory] {
        set param(maxhistory) $maxhistory
    }
    if [info exists fcolor] {
        set param(fcolor) $fcolor
    }
    if [info exists bcolor] {
        set param(bcolor) $bcolor
    }
    if [info exists tfont] {
        set param(tfont) $tfont
    }
    if [info exists lang] {
        set gparam(lang) $lang
    }

} else {
    if {$searchmpos == ""} {
        set searchmpos 0
    }
    foreach i $searchmpos {
        if [cmd_avail $searchmeth($i,grepcmd)] {
            incr cmds
            set searchmeth($i,avail) 1
        } else {
            set searchmeth($i,avail) 0
        }

        if {! [info exists searchmeth($i,foldedresult)]} {
            set fold [expr {[info exists default_searchmeth($i,foldedresult)] ? $default_searchmeth($i,foldedresult) : $default_searchopts(foldedresult)}]
            debug 2 "set searchmeth($i,foldedresult) to $fold"
            set searchmeth($i,foldedresult) $fold
        }

        # Change path of default ger-eng.txt when upgrading from version 1.1
        if {$searchmeth($i,dictfile) == {/usr/dict/ger-eng.txt} &&
            $ding_version == {1.1}} {
            set searchmeth($i,dictfile) $default_searchmeth(0,dictfile)
            debug 2 "New path and name of ger-eng.txt configured: $default_searchmeth(0,dictfile)"
        } elseif {$searchmeth($i,dictfile) == {/usr/share/dict/ger-eng.txt}} {
            set searchmeth($i,dictfile) $default_searchmeth(0,dictfile)
            debug 2 "New name of ger-eng.txt configured: $default_searchmeth(0,dictfile)"
        }

        set df [glob -nocomplain $searchmeth($i,dictfile)]
        set searchmeth($i,dictfiles) $df
    }
}
if [expr $param(debug) & 8] {
    debug 8 "Search methods:"
    foreach m [lsort [array names searchmeth]] {
        puts stderr " $m: $searchmeth($m)"
    }
}
set param(cursearchmeth) 0

# set program colors
if {[string length $param(bcolor)] != 7 ||
    [scan $param(bcolor) "#%2x%2x%2x" red green blue] != 3 ||
    [string length $param(fcolor)] != 7 || 
    [scan $param(fcolor) "#%2x%2x%2x" red green blue] != 3} {

    set param(bcolor)           $default(bcolor)
    set param(fcolor)           $default(fcolor)
}
tk_setPalette foreground $param(fcolor) background $param(bcolor)

if { ![string compare $gparam(grepcmd) ""] && $cmds < 1} {
    # no search command found ...
    errorBox "No grep commands like [array names default_grepcmds] found.
Check your PATH and/or install a grep command.
Exiting ..."
    exit
}
# Define Font names
proc defFonts {} {
    global param
    # Pixel size for Unix - looks better
    set pixel [expr {$param(isunix) ? "-" : ""}]

    if [string length [lindex $param(lfont) 2]] {
        set weight [lindex $param(lfont) 2]
    } else {
        set weight {normal}
    }
    font create lfont -family [lindex $param(lfont) 0] \
        -size $pixel[lindex $param(lfont) 1] -weight $weight

    if [string length [lindex $param(bfont) 2]] {
        set weight [lindex $param(bfont) 2]
    } else {
        set weight {bold}
    }
    font create bfont -family [lindex $param(bfont) 0] \
        -size $pixel[lindex $param(bfont) 1] -weight $weight

    if [string length [lindex $param(ifont) 3]] {
        set slant [lindex $param(ifont) 3]
    } else {
        set slant {italic}
    }
    font create ifont -family [lindex $param(ifont) 0] \
        -size $pixel[lindex $param(ifont) 1] -slant $slant

    if [string length [lindex $param(sfont) 2]] {
        set weight [lindex $param(sfont) 2]
    } else {
        set weight {normal}
    }
    font create sfont -family [lindex $param(sfont) 0] \
        -size $pixel[lindex $param(sfont) 1] -weight $weight

    if [string length [lindex $param(tfont) 2]] {
        set weight [lindex $param(tfont) 2]
    } else {
        set weight {normal}
    }
    font create tfont -family [lindex $param(tfont) 0] \
        -size $pixel[lindex $param(tfont) 1] -weight $weight

    if [string length [lindex $param(ipafont) 2]] {
        set weight [lindex $param(ipafont) 2]
    } else {
        set weight {normal}
    }
    font create ipafont -family [lindex $param(ipafont) 0] \
        -size $pixel[lindex $param(ipafont) 1] -weight $weight

    # font create ipafont -family lucidatypewriter -size -14 -weight normal
}

# Change result font: how - 1 = bigger, -1 = smaller, 0 = default
proc change_font {how} {
    global param default
    if {$how == 0} {        # default
        set param(tfont) [list [lindex $param(tfont) 0] [lindex $default(tfont) 1] [lindex $param(tfont) 2]]
        set param(ifont) [list [lindex $param(ifont) 0] [lindex $default(tfont) 1] [lindex $param(ifont) 2] [lindex $param(ifont) 3]]
        set param(ipafont) [list [lindex $param(ipafont) 0] [lindex $default(ipafont) 1] [lindex $param(ipafont) 2]]
    } else {
        set fs [expr [lindex $param(tfont) 1] + $how]
        if {$fs > 4} {      # greater than minimum font size
            set param(tfont) [list [lindex $param(tfont) 0] $fs [lindex $param(tfont) 2]]
            set param(ifont) [list [lindex $param(ifont) 0] $fs [lindex $param(ifont) 2] [lindex $param(ifont) 3]]
            set param(ipafont) [list [lindex $param(ipafont) 0] $fs [lindex $param(ipafont) 2]]
        }
    }
    chFont tfont
    chFont ifont
    chFont ipafont
    .statusBar.lab config -foreground $param(fcolor) -text "$param(tfont)"
}

proc chFont {font} {
    global param
    # Pixel size for Unix - looks better
    set pixel [expr {$param(isunix) ? "-" : ""}]

    if [string length [lindex $param($font) 2]] {
        set weight [lindex $param($font) 2]
    } else {
        set weight {normal}
    }
    if {[string length [lindex $param($font) 3]] && 
        [lindex $param($font) 3] == {italic}} {
        set slant {italic}
    } else {
        set slant {roman}
    }
    font configure $font -family [lindex $param($font) 0] \
        -size $pixel[lindex $param($font) 1] -weight $weight -slant $slant
}

defFonts

# if {![string compare $searchmeth($param(cursearchmeth),grepcmd) ""]} {
# } else {
#     set default_searchopts(grepcmd) $searchmeth($param(cursearchmeth),grepcmd)
# }

if {[winfo depth .] > 1} {      # Color display
    set param(errcolor) red
} else {
    set param(errcolor) black
}

#########################################################################
# Balloon help, by John Haxby <jch@pwd.hp.com>, with slight changes
# by Axel Boldt <boldt@math.ucsb.edu>.

proc BalloonInit {} {
    global param

    
bind balloon <Enter> {
    if { [info exists balloonHelp(%W)] && [%W cget -state] != "disabled"} {
        set balloonHelp(%W,after) [after $param(balloonDelay) {showBalloonHelp %W}]
    }
}

bind balloon <Leave> { unShowBalloonHelp %W }
bind balloon <Any-KeyPress> { unShowBalloonHelp %W }
bind balloon <Any-Button> { unShowBalloonHelp %W }

proc showBalloonHelp {w} {
    global balloonHelp param gparam
    if {![info exists balloonHelp($w)] || ! $param(showBalloons) } {
        return
    }
    update idletasks
    set curpos [winfo pointerxy $w]
    set curwin [eval winfo containing $curpos]
    if { $w == $curwin } {
        if ![winfo exists .balloon] {
            toplevel .balloon
            wm overrideredirect .balloon true
            pack [label .balloon.l -font lfont \
                    -foreground black \
                    -background $gparam(balloonBackground) \
                    -highlightthickness 1 \
                    -highlightbackground black]
            wm withdraw .balloon
        }
        .balloon.l configure -text $balloonHelp($w)
        set x [expr [lindex $curpos 0] - 14]
        set y [expr [lindex $curpos 1] + 19]
        wm geometry .balloon +$x+$y
        # This update is important to have the geometry command take 
        # effect in all cases (A.B.)
        update idletasks
        raise .balloon
        wm deiconify .balloon
    }
}
proc unShowBalloonHelp {w} {
    global balloonHelp
    if [info exists balloonHelp($w,after)] {
        after cancel $balloonHelp($w,after)
        unset balloonHelp($w,after)
    }
    catch {wm withdraw .balloon}
}

# end of proc BalloonInit
} 

BalloonInit
###############

# calculate other colors from given foreground and background colors
proc shadeColor {fcolor bcolor} {
    
    debug 2 "shadeColor $fcolor $bcolor"
    # the higher the following values
    # the more different is the shaded/hilite  color, max 127
    set dc1 16
    set dc2 32

    if {[scan $bcolor "#%2x%2x%2x" red green blue] != 3} {
        set rgb [winfo rgb . $bcolor]
        set red   [expr {[lindex $rgb 0]/0x100}]
        set green [expr {[lindex $rgb 1]/0x100}]
        set blue  [expr {[lindex $rgb 2]/0x100}]
    }
    debug 8 "  old bcolor = $red $green $blue"
    set red   [expr $red < (255 - $dc1) ? [expr $red + $dc1] : [expr $red - $dc1]]
    set green [expr $green < (255 - $dc1) ? [expr $green + $dc1] : [expr $green - $dc1]]
    set blue  [expr $blue < (255 - $dc1) ? [expr $blue + $dc1] : [expr $blue - $dc1]]
    set bc [format "#%02x%02x%02x" $red $green $blue]

    set red   [expr $red < (255 - $dc2) ? [expr $red + $dc2] : [expr $red - $dc2]]
    set green [expr $green < (255 - $dc2) ? [expr $green + $dc2] : [expr $green - $dc2]]
    set blue  [expr $blue < (255 - $dc2) ? [expr $blue + $dc2] : [expr $blue - $dc2]]
    set hc [format "#%02x%02x%02x" $red $green $blue]

    set ec [format "#%02x%02x%02x" [expr $red < 128 ? 255 : $red] [expr $green < 128 ? 128 : 0] [expr $blue < 128 ? 128 : 0]]
    # [expr 255 - $green] [expr 255 - $blue]]

    if {[scan $fcolor "#%2x%2x%2x" red green blue] != 3} {
        set rgb [winfo rgb . $fcolor]
        set red   [expr {[lindex $rgb 0]/0x100}]
        set green [expr {[lindex $rgb 1]/0x100}]
        set blue  [expr {[lindex $rgb 2]/0x100}]
    }
    debug 8 "  old fcolor = $red $green $blue"
    # set red [expr $red < 128 ? 255 : 0]
    # set green [expr $green < 128 ? 255 : 0]
    set blue [expr $blue < 128 ? 255 : 0]
    set fc [format "#%02x%02x%02x" $red $green $blue]

    debug 8 "  new colors = $bc $fc $ec $hc"
    return [list $bc $fc $ec $hc]
}

proc setSearchBg {color} {
    .search.s configure -background $color
    .search.s.label.label configure -background $color
    .search.l configure -background $color
    .search.l.logo configure -background $color
    .search configure -background $color
}

# updates the menu for search methods when changed
proc update_searchmeth_menu {} {
    global searchmeth searchmpos param gparam s 

    debug 2 "update_searchmeth_menu"
    set lang $gparam(lang)
    variable i
    .search.s.searchmeth.m delete 0 end
    set n 0
    foreach i $searchmpos {
        if $searchmeth($i,avail) {
            incr n
            set cmd "
                set param(cursearchmeth) $i
                .search.s.searchmeth configure -text {$searchmeth($i,name)}
                .statusBar.lab config -foreground $param(fcolor) \
                    -text {[set s($lang)(cmd)] $searchmeth($i,grepcmd)}
                .statusBar.file config -foreground $param(fcolor) \
                    -text {$searchmeth($i,dictfile)}
                set_opts_errors {$i}
               after cancel dictsearchquery_onchange
               after $param(autosearchDelay) dictsearchquery_onchange
            "
            if {$n < 10} {
                bind .search.s.entry <Control-KeyPress-$n> "$cmd"
                .search.s.searchmeth.m add command -font lfont \
                    -accelerator "[set s($lang)(ctl)]+$n" \
                    -label [set searchmeth($i,name)] -command $cmd \
            } else {
                .search.s.searchmeth.m add command -font lfont \
                    -label [set searchmeth($i,name)] -command $cmd
            }
         }
    }
    .search.s.searchmeth configure -text $searchmeth($param(cursearchmeth),name)
    .statusBar.file config -foreground $param(fcolor) \
                        -text "$searchmeth($param(cursearchmeth),dictfile)"
}

# manipulates menu for opts(errors)
# - active only for search methods which support error correction
proc set_opts_errors {i} {
    global searchmeth opts param

    debug 2 "set_opts_errors"
    if {  ([string match "*grep*" $searchmeth($i,grepcmd)] && \
      [string match "agrep*" $searchmeth($i,grepcmd)]) ||
      [string match "dict*" $searchmeth($i,grepcmd)]} {
    # only agrep and dict (limited) have error correction
        .search.opts.errors configure -state normal
        .menuBar.params entryconfigure 8 -state normal
        .menuBar.params entryconfigure 9 -state normal
        .menuBar.params entryconfigure 10 -state normal
        .menuBar.params entryconfigure 11 -state normal
        .menuBar.params entryconfigure 12 -state normal
    } else {
        # save old state ???
        set opts(errors) 0
        .search.opts.errors configure -state disabled
        .menuBar.params entryconfigure 8 -state disabled
        .menuBar.params entryconfigure 9 -state disabled
        .menuBar.params entryconfigure 10 -state disabled
        .menuBar.params entryconfigure 11 -state disabled
        .menuBar.params entryconfigure 12 -state disabled
    }
}

# Escape: reset interface (kill search process, reset cursor, stop anim logo)
proc Reset {mini} {
    global proc param gparam s

    debug 2 "Reset"
    set lang $gparam(lang)
    if {$proc(pid) > 0} {
      if {$param(isunix)} {
        debug 4 "  kill $proc(pid)"
        if [catch {exec kill $proc(pid)} err] {
            .statusBar.lab config -foreground $param(errcolor) -text "[set s($lang)(nokill)] $err"
        } else {
            set $proc(pid) -1
            .statusBar.lab config -foreground $param(fcolor) -text [set s($lang)(kill)]
        }
      }
    } elseif {$proc(pid) == 0} {
        # internal search
        debug 4 "Stopping internal"
        set proc(pid) -1
    }
    interface_reset $mini 
}

# Scrollbars when needed, http://mini.net/cgi-bin/wikit/BagOfTkAlgorithms
# scrollbars come and go as needed -- see Welch 8.0/347f.
proc yscroll {bar cmd offset size} {
    # debug 8 "yscroll $bar \"$cmd\" $offset $size"
    if {$offset == 0 && $size == 0} {
        return
    }
    if {$offset != 0.0 || $size != 1.0} {
        # grid configure .result.text -rowspan 1
        eval $cmd
    }
    $bar set $offset $size
}
proc xscroll {bar cmd offset size} {
    # debug 8 "xscroll $bar \"$cmd\" $offset $size"
    if {$offset == 0 && $size == 0} {
        return
    }
    if {$offset != 0.0 || $size != 1.0} {
        grid configure .result.text -columnspan 1
        eval $cmd
    }
    $bar set $offset $size
}

# show (full window) or hide (minimize window) the result frame
# type  0 = hide, 1 = show, -1 = toggle

proc hideResult {type} {
    global param s lang balloonHelp
    debug 2 "hideResult $type"
    set x 0
    set y 0
    # update
    set geo [wm geometry .]
    scan $geo "%dx%d+%d+%d" w h x y
    set where {}
    set wx [winfo x .]
    set wy [winfo y .]
    if {$x == 0 && $y == 0} {
        if {${wx} != 0 && ${wy} != 0} {
            # set where "+${wx}+${wy}"
        }
    } else {
        set where "+$x+$y"
    }
    debug 8 "  toplevel geometry: $geo (= $w $h $x $y) winfo: $wx $wy -> $where"

    set visible [winfo viewable .result]
    # show
    if {($type == 1 && ! $visible) || ($type == -1 && ! $visible)} {
        pack .result -fill both -expand yes
        debug 8 "  show result"
        set param(show_result) 1
        hideMenuBar -1
        hideStatusBar -1
        if {[info exists param(width)] && [info exists param(height)]} {
            set height [expr $param(height) + $param(add_geom_height)]
            debug 8 "  setting geometry: $param(width)x$height$where"
            bind dlookup <Configure> {}

            wm geometry . "$param(width)x$height$where"
            update
            debug 8 "  after setting: [wm geometry .] [winfo height .] "
            set wh [winfo height .]
            if {$height != $wh} {
                # correction of height for some window managers
                debug 8 "Window manager sets false height: should $height, is $wh."
                set param(add_geom_height) [expr $param(height) - $wh]
                ## should be: requested height + correction
                set height [expr $param(height) + $param(add_geom_height)]
                # for KDE this works: setting requested height again
                set height $param(height)
                debug 8 "  setting geometry: $param(width)x$height$where"
                wm geometry . "$param(width)x$height$where"
                update
                debug 8 "  after setting: [wm geometry .] [winfo height .] "
            }
            bind dlookup <Configure> catch_resize
        } else {    
            wm geometry . {}
        }
        set balloonHelp(.search.l.logo) [set s($lang)(minimize)]
        .popup entryconfigure 7 -label [set s($lang)(minimize)]
        return
    }
    # hide
    if {($type == 0 && $visible) || ($type == -1 && $visible)} {
        pack forget .result
        debug 8 "  hide result"
        if {$param(do_automin) == 1 && $param(win_prop) == 2 && $param(autominDelay) > 0} {
            debug 2 " cancelling automatically minimize <Enter>"
            after cancel {hideResult 0}
        }    
        set param(show_result) 0
        hideMenuBar 0
        hideStatusBar 0
        if [info exists param(width)] {
            set w $param(width)
        } else {
            set w [winfo width .search]
        }
        debug 8 "  setting geometry: ${w}x[winfo height .search]$where"
        wm geometry . "${w}x[winfo height .search]$where"
        # wm geometry . {}
        set balloonHelp(.search.l.logo) [set s($lang)(normalsize)]
        .popup entryconfigure 7 -label [set s($lang)(normalsize)]
        return
    }
    debug 2 "hideResult - status ok, nothing done"
}

# proc to show or hide the menu bar
# type  0 = hide, 1 = show, -1 = show if user wants to see

proc hideMenuBar {type} {
    global param s lang
    debug 8 "hideMenuBar $type"

    # show
    if {$type == 1} {
        . configure -menu .menuBar
        set param(show_menu) 1
        .popup entryconfigure 8 -label [set s($lang)(hide_menu)]
        debug 8 "  show menu"
    } elseif {$type == 0} {
    # hide
        . configure -menu .nomenuBar
        # set param(show_menu) 0
        .popup entryconfigure 8 -label [set s($lang)(show_menu)]
        if {$param(show_result) == 1 && $param(show_status) == 1} {
            .statusBar.lab config -foreground $param(fcolor) -text [set s($lang)(show_menu_desc)]
        }
        debug 8 "  hide menu"
    # type == -1
    } elseif {$param(show_menu) == 1} {
        . configure -menu .menuBar
        .popup entryconfigure 8 -label [set s($lang)(hide_menu)]
        debug 8 "  show menu"
    } else {
        # hide
        . configure -menu .nomenuBar
        .popup entryconfigure 8 -label [set s($lang)(show_menu)]
        debug 8 "  hide menu"
    }

}

# 0 - off, 1 = on, -1 = show if user wants to see
proc hideStatusBar {type} {
    global param s lang

    debug 8 "hideStatusBar $type"
    # show
    if {$type == 1} {
        pack .statusBar -side bottom -fill x -pady 1 -padx 1 -before .result
        set param(show_status) 1
        .popup entryconfigure 9 -label [set s($lang)(hide_status)]
        debug 8 "  show status"
    } elseif {$type == 0} {
        # hide
        pack forget .statusBar
        # set param(show_status) 0
        .popup entryconfigure 9 -label [set s($lang)(show_status)]
        debug 8 "  hide status"
    } elseif {$param(show_status) == 1 && ![winfo viewable .statusBar]} {
        pack .statusBar -side bottom -fill x -pady 1 -padx 1 -before .result
        .popup entryconfigure 9 -label [set s($lang)(hide_status)]
        debug 8 "  show status"
    } else {
        # hide
        pack forget .statusBar
        .popup entryconfigure 9 -label [set s($lang)(show_status)]
        debug 8 "  hide status"
    }
}

proc welcome {start} {
    global param searchmpos searchmeth s lang pinfo

    set t .result.text
    set big {Helvetica 18 bold}
    $t tag configure h1 -background $param(shadedcolor) -foreground $param(fcolor) -font $big -justify center
    .result.text tag configure cmd -background $param(bcolor) \
        -relief groove -borderwidth 1 -lmargin1 5 -spacing1 3 -spacing3 3 \
        -font lfont
    .result.text tag configure th -background $param(shadedcolor) -font bfont \
        -relief groove -borderwidth 1 -lmargin1 5 -spacing1 3 -spacing3 3
    $t tag configure c -justify center -font bfont -background $param(bcolor)
    $t tag configure infolink -foreground $param(highcolor) -underline 1 \
        -justify center -font bfont
    $t tag bind infolink <ButtonRelease-1> { aboutBox }
    $t tag bind infolink <Enter> " $t config -cursor hand2"
    $t tag bind infolink <Leave> " $t config -cursor xterm"
    $t configure -state normal

    $t delete 0.0 end
    if {$start} {
        .result.text insert end "$pinfo(pname)\n" h1
        .result.text insert end "\nVersion $pinfo(version)  -  " c
        .result.text insert end "Info" infolink
        .result.text insert end "\n\n" c
    }
    # compute tab stop
    set width [winfo width $t]
    if {$width < 200} {
        set width 200
    }
    $t configure -tabs [expr round(($width / 2) - 2)]

    .result.text insert end "[set s($lang)(configured)] [set s($lang)(searchmeth)]\t" th
    .result.text insert end "[set s($lang)(grepcmd)] / [set s($lang)(dictfile)]\n" th
    foreach i $searchmpos {
        set what "$searchmeth($i,language1)"
        if [string length $searchmeth($i,language2)] {
            set what "$what $searchmeth($i,language2)"
        }
        if $searchmeth($i,avail) {
            .result.text insert end [format "%s (%s)\t%s %s %s\n" \
                $searchmeth($i,name) $what \
                $searchmeth($i,grepcmd) \
                $searchmeth($i,grepopts) \
                $searchmeth($i,dictfile) ] cmd
        }
    }
    .result.text configure -state disabled
    .result.text tag raise sel

    if {$start} {
        animlogo .search.l.logo
        after 1500 {
            after cancel animlogo .search.l.logo
            .search.l.logo configure -image "logo1"
        }
    }
}

# proc mainWindow {w} {
#     global pinfo argv0 argv param gparam s lang
#     global searchmeth opts defaultcursor
#     global grepcmds

# now build the user interface
set logo {
R0lGODdhIAAgAMIAAMDAwAAAAP///4CAgPJ8Dv///////////ywAAAAAIAAgAAADxRi63P5N
yEmrvVIJwLv/YDhoYWl6Y7CdLJiubQy8ALR0tsLRKiYENd9vpyH0MDWAMECYFY+X5LL5Mv4C
g4EgK5Eustwf9SmU+phOlVWiBXeBE7dWnBaskfDzWA21mDFoVX0VXlhbYYFkV1hhfxeJfGV5
gHt2UHMTZmCYdIJxh3OOFpCWkkqHGQyVa5sUokFXq4Ouk29DpHdRtRs6NbI2vEo5siZAxsXE
xb0luDlMBEbDddDU1dRg1tmVMjIpm9/g4eLO5MAJADs=}
image create photo windowicon -data $logo

wm title . $pinfo(pname)
if {$tk_version >= 8.5} {
    wm iconphoto . windowicon
}
wm iconname . $pinfo(pname)
wm command . [concat $argv0 $argv] 
wm client . [info hostname]
# wm group . .
# wm focusmodel . active

set lang $gparam(lang)

menu .menuBar -font lfont -tearoff 0 -relief groove -bd 1
menu .menuBar.file -tearoff 0 -font lfont
.menuBar.file add command -label "[set s($lang)(newwin)]..." \
    -underline 0 -accelerator "[set s($lang)(ctl)]+N" -command startNew 
.menuBar.file add command -label "[set s($lang)(save)]..." -command {save 0}  \
    -underline 0 -accelerator "[set s($lang)(ctl)]+S"
.menuBar.file add command -label "[set s($lang)(saveall)]..." -command {save 1} \
    -underline 0 -accelerator "[set s($lang)(ctl)]+L"
.menuBar.file add command -label "[set s($lang)(clipboard_copy_all)]" -command clipboard_copy_all \
    -underline 0 -accelerator "[set s($lang)(ctl)]+C"
.menuBar.file add command -label "[set s($lang)(notice)]..." \
    -command {notice $param(noticefile)} \
    -underline 1 -accelerator "[set s($lang)(ctl)]+O"
.menuBar.file add command -label "[set s($lang)(mail)]..." -command sendMail \
    -underline 0 -accelerator "[set s($lang)(ctl)]+M"
.menuBar.file add command -label [set s($lang)(quit)] -command {
    if {$param(autosave) != 0} {
        saveOptions
    }
    exit } \
    -underline 0 -accelerator "[set s($lang)(ctl)]+Q"
.menuBar add cascade -menu .menuBar.file -label [set s($lang)(file)] -underline 0

menu .menuBar.opts -tearoff 0  -font lfont
.menuBar.opts add checkbutton -label [set s($lang)(show_menu)] \
        -variable param(show_menu) -command {hideMenuBar $param(show_menu)} \
        -accelerator "[set s($lang)(shift)]+[set s($lang)(ctl)]+[set s($lang)(space)]"

.menuBar.opts add checkbutton -label [set s($lang)(params_as_menu)] \
        -variable param(params_as_menu) -command {
                if $param(params_as_menu) {
                    pack .search.opts -pady 2
                } else {
                    pack forget .search.opts
                }
            }
.menuBar.opts add checkbutton -label [set s($lang)(umlaut_buttons)] \
        -variable param(umlaut_buttons) -command {
                if $param(umlaut_buttons) {
                    pack .search.u -pady 2
                } else {
                    pack forget .search.u
                }
            }
# .menuBar.opts add checkbutton -label [set s($lang)(show_result)] \
#         -variable param(show_result) -command {hideResult $param(show_result)} \
#         -accelerator "[set s($lang)(ctl)]+[set s($lang)(space)]"

.menuBar.opts add checkbutton -label [set s($lang)(show_status)] \
        -variable param(show_status) -command \
            { hideStatusBar $param(show_status)}

.menuBar.opts add separator
.menuBar.opts add command -label [set s($lang)(larger_font)] -command "change_font 1" \
        -accelerator "[set s($lang)(ctl)]++"
.menuBar.opts add command -label [set s($lang)(smaller_font)] -command "change_font -1" \
        -accelerator "[set s($lang)(ctl)]+-"
.menuBar.opts add command -label [set s($lang)(default_font)] -command "change_font 0" \
        -accelerator "[set s($lang)(ctl)]+0"

.menuBar.opts add separator
.menuBar.opts add command -label [set s($lang)(general)] -command "setGeneral" -underline 0 
.menuBar.opts add command -label [set s($lang)(soptions)] -command "setSearch" -underline 0 
.menuBar.opts add command -label [set s($lang)(saveopts)] -command "saveOptions" -underline 0

if {$gparam(noconf)} {
    .menuBar.opts entryconfigure 11 -state disabled
}

.menuBar add cascade -menu .menuBar.opts -label [set s($lang)(options)] -underline 0

# Search parameters as menu?
    menu .menuBar.params -tearoff 1 -font lfont 

    .menuBar.params add radiobutton -label [set s($lang)(word)(0)] \
        -value 0 -variable opts(word)
    .menuBar.params add radiobutton -label [set s($lang)(word)(1)] \
        -value 1 -variable opts(word)

    .menuBar.params add separator
    .menuBar.params add radiobutton -label [set s($lang)(case)(0)] \
        -value 0 -variable opts(case)
    .menuBar.params add radiobutton -label [set s($lang)(case)(1)] \
        -value 1 -variable opts(case)
    
    .menuBar.params add separator
    for {set x 0} {$x < 5} {incr x} {
        set e [expr $x == 1 ? {[set s($lang)(error)]} : {[set s($lang)(errors)]}]
        .menuBar.params add radiobutton -label "$x $e" \
            -value $x -variable opts(errors)
    }
    .menuBar.params add radiobutton -label [set s($lang)(closestmatch)] \
        -value -1 -variable opts(errors)
    
    .menuBar.params add separator
    .menuBar.params add radiobutton -label [set s($lang)(regex)(0)] \
        -value 0 -variable opts(regex)
    .menuBar.params add radiobutton -label [set s($lang)(regex)(1)] \
        -value 1 -variable opts(regex)

.menuBar add cascade -menu .menuBar.params -label  [set s($lang)(params)] \
    -underline 0

# Program behavior menu
    menu .menuBar.props -tearoff 1 -font lfont 

    .menuBar.props add radiobutton -label [set s($lang)(onrequest)] \
        -value 0 -variable param(search_prop) \
        -command {after cancel check_selection; 
                  .search.s.label.mark configure -background green }
    .menuBar.props add radiobutton -label [set s($lang)(onmouseover)] \
        -value 1 -variable param(search_prop) \
        -command {after cancel check_selection; 
                  .search.s.label.mark configure -background yellow }
    .menuBar.props add radiobutton -label [set s($lang)(onselection)] \
        -value 2 -variable param(search_prop) \
        -command { .search.s.label.mark configure -background red }

    .menuBar.props add separator
    .menuBar.props add radiobutton -label [set s($lang)(min_none)] \
        -value 0 -variable param(win_prop)
    .menuBar.props add radiobutton -label [set s($lang)(min_focus_delay)] \
        -value 2 -variable param(win_prop)
    .menuBar.props add radiobutton -label [set s($lang)(min_focus)] \
        -value 1 -variable param(win_prop)

    .menuBar.props add separator
    .menuBar.props add checkbutton -label [set s($lang)(raise)] \
        -onvalue 1 -offvalue 0 -variable param(raise)
    .menuBar.props add checkbutton -label [set s($lang)(autosearch)] \
        -onvalue 1 -offvalue 0 -variable param(autosearch)

.menuBar add cascade -menu .menuBar.props -label  [set s($lang)(props)] \
    -underline 1

menu .menuBar.help -tearoff 0  -font lfont
.menuBar.help add command -label  [set s($lang)(help)] -command "helpGeneral" \
    -underline 0 -accelerator "F1"
.menuBar.help add command -label  [set s($lang)(khelp)] -command "helpKeys" \
    -underline 0
.menuBar.help add command -label  [set s($lang)(abbhelp)] -command "helpAbb" \
    -underline 0
.menuBar.help add command -label  [set s($lang)(cmdline)] \
    -command "helpCmdline" -underline 0
.menuBar.help add command -label  [set s($lang)(searchmeth)] -command "welcome 0" \
    -underline 0
.menuBar.help add sep
.menuBar.help add command -label "Homepage" -command "urlOpen $pinfo(homepage)"
.menuBar.help add sep
.menuBar.help add command -label  [set s($lang)(about)] -command "aboutBox" \
    -underline 0
.menuBar add cascade -menu .menuBar.help -label  [set s($lang)(help)] -underline 0

# the "no menu bar" - empty
menu .nomenuBar -bd 0

if {(! $mini) && $param(show_menu) == 1} {
    . configure -menu .menuBar
} else {
    . configure -menu .nomenuBar
}

# Pop up menu
menu .popup -tearoff 0 -font lfont
.popup add command -label [set s($lang)(bbhistory)] -command { history back } \
    -accelerator "[set s($lang)(ctl)]+[set s($lang)(up)]" -state disabled
.popup add command -label [set s($lang)(bfhistory)] -command { history forward } \
    -accelerator "[set s($lang)(ctl)]+[set s($lang)(down)]" -state disabled

.popup add separator
.popup add command -label [set s($lang)(save)] -command {save 0}  \
    -underline 0 -accelerator "[set s($lang)(ctl)]+S"
.popup add command -label [set s($lang)(clipboard_copy_line)] -command {
        .result.text tag remove sel 1.0 end
        #.result.text tag add sel [.result.text tag ranges hilite]
        if {[string compare [.result.text index "@$tkPriv(x),$tkPriv(y) linestart"] "1.0"]} {
            .result.text tag remove sel 1.0 end
            .result.text tag add sel "@$tkPriv(x),$tkPriv(y) linestart" "@$tkPriv(x),$tkPriv(y) lineend"
        }
        if {$param(isunix)} {
            catch {set last_selection [selection get]}
        } else {
            catch {set last_selection [selection get -selection CLIPBOARD]}
        }
        catch {clipboard clear}
        catch {clipboard append $last_selection}
    }
.popup add command -label [set s($lang)(clipboard_copy_all)] \
    -accelerator "[set s($lang)(ctl)]+C" -command clipboard_copy_all

.popup add separator
.popup add command -label [set s($lang)(minimize)] -command { hideResult -1 } \
    -accelerator "[set s($lang)(ctl)]+[set s($lang)(space)]"
.popup add command -label [if {$param(show_menu) == 1} \
    {set s($lang)(hide_menu)} else {set s($lang)(show_menu)}] \
    -command { debug 8 "$param(show_menu) $mini"
 if {$param(show_menu) == 1 && $param(show_result) == 1} {set param(show_menu) 0} else {set param(show_menu) 1}
    hideMenuBar $param(show_menu) } \
    -accelerator "[set s($lang)(shift)]+[set s($lang)(ctl)]+[set s($lang)(space)]"

.popup add command -label [if {$param(show_status) == 1} \
    {set s($lang)(hide_status)} else {set s($lang)(show_status)}] \
    -command { 
        debug 8 "$param(show_status)"
        if {$param(show_result) == 1} {
            set param(show_status) [expr $param(show_status) == 0 ? 1 : 0]
            hideStatusBar $param(show_status) 
        }
    }

frame .search -background white
pack .search -side top -fill x -expand 0

frame .search.l

pack .search.l -side right -fill y -padx 2

image create photo logo1 -data $logo
image create photo logo2 -data {
R0lGODdhIAAgAMIAAMDAwAAAAP///4CAgPJ8Dv///////////ywAAAAAIAAgAAAD2Bi63P5N
yEmrvVIJwLv/nwIOGmiCgRCM5emmKpu6Jxx/5AwtnTY1nNzGdlkRB6pfUEMgWgCrCTKZIQCE
TYwECpBMqSorNqUYIM3bKAwZmAbETGeF67S9r3GpwDzl6sF3Y1pDXXs/bnApWVp+FCQ/iQKL
GHR6dpGLC3xphRRtVXiKchSNbpehkkdzUW6AmDZnaIQwOmiBeYxRVLphqIt8X4RKvLeig40q
vL2CuYUiFcWpO8I70U0vdC+vNDzavtVvBE3VmOLm5+J86OuRNO4mOcDy8/T14PfTCQA7}
image create photo logo3 -data {
R0lGODdhIAAgAMIAAMDAwAAAAP///4CAgPJ8Dv///////////ywAAAAAIAAgAAADzxi63P5N
yEmrvVIJwLv/QAB+gzaeytmVwaZ6rfiy7htmNh1CactCHF0LIxgWMTIawXjxHZsEgJJpCQwy
1Ex0WrReB9fnTwAOB7aaJfF4zWqlaeMXnJloquiWmuj0zt9cfGZIeQJ7SHaEcHpDC2V1XV2P
RYWHTUdulIuGTGF2MTd4m4dznkVBdGRtlZkZJQAVnmejQ2WmKRKpFLOBSAOwfKxrVsCKUzwb
IjwKrCrKryjNzinOrMsE2Mu8adjd3thl3+KFNuUkCrbp6uvs2u7ICQA7}
image create photo logo4 -data {
R0lGODdhIAAgAMIAAMDAwAAAAP///4CAgPJ8Dv///////////ywAAAAAIAAgAAAD2xi63P5N
yEmrvVIJwDsPXih6gzYCyqkCZbCNLriK7Su6gjx3NfpkHciC08NNUBOQ8SKrEZYbDRCTIbA0
zwoSB8owrc5YYDBAJgE5DXlQvbqyFDO7Sw2AsUZ2TVBCSyt2bgJwRzFTfGSIbWFaOHNodXdv
UD5nVDmSg1wphjl+aWuLeIBJnpeBjBQubFN/qpmEJROsdKGKqKNJtaYVrJiCcGuVj4i+SbCU
H4cYuJMXynTMyEJKfkLIKkM6N9jZKdnT1wRP1LDj5+jja+nsmTvvPApr8/T19vTU+fkCCQA7}
image create photo logo5 -data {
R0lGODdhIAAgAMIAAMDAwAAAAP///4CAgPJ8Dv///////////ywAAAAAIAAgAAAD3Ri63P5N
yEmrvVIJwLnqYCh2gxYGQjCuYYmeGSu7G4jG8kgD0fR5kN/uxktRVDeMCkAjEG9JHgCTITA1
TkmxIs1cAtYmCikYSMzdRXlgToWxT1R70KWCr6jsZkwpTTUWd2JaUBN1bGZsVXgCeltlhFN2
b3lPRpB1SpSNUIWRRgqIi4N7Pp+TjI5yFGlJR5uqZ4YqZ4prbqlJSW2ZE224pHSue1OiFYJw
rBpotKikhlu9gbBBL7TV1CxIUivIlTIL4NTYBE7YqeXp6uWI6+6bOfEtoYj19vf49dX7+wIJ
ADs=}
image create bitmap left -foreground $param(fcolor) -data {
#define l_width 9
#define l_height 13
static char l_bits[] = {
 0x80,0x00,0xc0,0x00,0xe0,0x00,0x70,0x00,0x38,0x00,0x1c,0x00,0x0e,0x00,0x1c,
 0x00,0x38,0x00,0x70,0x00,0xe0,0x00,0xc0,0x00,0x80,0x00};
}
image create bitmap right -foreground $param(fcolor) -data {
#define r_width 9
#define r_height 13
static char r_bits[] = {
 0x02,0x00,0x06,0x00,0x0e,0x00,0x1c,0x00,0x38,0x00,0x70,0x00,0xe0,0x00,0x70,
 0x00,0x38,0x00,0x1c,0x00,0x0e,0x00,0x06,0x00,0x02,0x00};
}
image create bitmap up -foreground $param(fcolor) -data {
#define u_width 13
#define u_height 9
static char u_bits[] = {
 0x00,0x00,0x40,0x00,0xe0,0x00,0xf0,0x01,0xb8,0x03,0x1c,0x07,0x0e,0x0e,0x07,
 0x1c,0x00,0x00};
}
image create bitmap down -foreground $param(fcolor) -data {
#define d_width 13
#define d_height 9
static char d_bits[] = {
 0x00,0x00,0x07,0x1c,0x0e,0x0e,0x1c,0x07,0xb8,0x03,0xf0,0x01,0xe0,0x00,0x40,
 0x00,0x00,0x00};
}
image create bitmap plus -foreground $param(bcolor) -background $param(fcolor) -data {
#define plus_width 8
#define plus_height 8
static unsigned char plus_bits[] = {
   0x00, 0x18, 0x18, 0x7e, 0x7e, 0x18, 0x18, 0x00};
}
image create bitmap minus -foreground $param(bcolor) -background $param(fcolor) -data {
#define minus_width 8
#define minus_height 8
static unsigned char minus_bits[] = {
   0x00, 0x00, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x00};
}

button .search.l.logo -image logo1 -bd 1 -relief raised -command {Reset 1}
pack .search.l.logo -side right -expand 1 -anchor n

set balloonHelp(.search.l.logo) [set s($lang)(minimize)]
bindtags .search.l.logo [list balloon .search.l.logo Button all]

set logoanim 1
proc animlogo {t} {
    global logoanim

    # debug 2 "animlogo $t"
    if ![winfo exists $t] {
        after cancel animlogo $t
        return
    }
    if {$logoanim >= 5} {
        set logoanim 1
    } else {
        incr logoanim
    }
    $t configure -image "logo$logoanim"
    after 100 "animlogo $t"
}

frame .search.s -background white
pack .search.s -side top -expand 1 -fill x -padx 5
if {$tk_version > 8.3} {
    button .search.s.back -state disabled -height 15 -width 15 -image left \
    -relief flat -overrelief raised -command { history back }
} else {
    button .search.s.back -state disabled -height 15 -width 15 -image left \
    -relief raised -command { history back }
}

set balloonHelp(.search.s.back) [set s($lang)(bbhistory)]
bindtags .search.s.back [list balloon .search.s.back Button all]

if {$tk_version > 8.3} {
    button .search.s.forw -state disabled -height 15 -width 15 -image right \
    -relief flat -overrelief raised -command { history forward }
} else {
    button .search.s.forw -state disabled -height 15 -width 15 -image right \
    -relief raised -command { history forward }
}
set balloonHelp(.search.s.forw) [set s($lang)(bfhistory)]
bindtags .search.s.forw [list balloon .search.s.forw Button all]

# fri: label -> button
#  label .search.s.label -text " [set s($lang)(query)]" -font lfont

#frame .search.s.label -pady 0
#frame .search.s.label.mark -pady 1
frame .search.s.label
frame .search.s.label.mark
switch $param(search_prop) {
    "0" { .search.s.label.mark configure -background green }
    "1" { .search.s.label.mark configure -background yellow }
    "2" { .search.s.label.mark configure -background red }
}

button .search.s.label.label -text " [set s($lang)(query)]" -font lfont \
    -relief flat -command { 
        # toggle search property: onrequest, onmouseover, onselect
        if {$param(search_prop) == 0} {
            set param(search_prop) 1
            .search.s.label.mark configure -background yellow
            .statusBar.lab config -foreground $param(fcolor) -text \
                "[set s($lang)(props)]: [set s($gparam(lang))(onmouseover)]"

        } elseif {$param(search_prop) == 1} {
            set param(search_prop) 2
           .search.s.label.mark configure -background red
            .statusBar.lab config -foreground $param(fcolor) -text \
                "[set s($lang)(props)]: [set s($gparam(lang))(onselection)]"
        } elseif {$param(search_prop) == 2} {
            set param(search_prop) 0
           .search.s.label.mark configure -background green
            .statusBar.lab config -foreground $param(fcolor) -text \
                "[set s($lang)(props)]: [set s($gparam(lang))(onrequest)]"
        }
    }
set balloonHelp(.search.s.label.label) [set s($lang)(change_props)]
bindtags .search.s.label.label [list balloon .search.s.label.label Button all]

entry .search.s.entry -width 17 -selectbackground $param(fcolor) -selectforeground $param(bcolor) \
    -textvariable query -relief flat -font tfont -bd 3

if {$tk_version > 8.3} {
    button .search.s.button -text [set s($lang)(search)] -font lfont \
    -relief flat -overrelief raised -command "dictsearch \$query"
} else {
    button .search.s.button -text [set s($lang)(search)] -font lfont \
    -relief raised -command "dictsearch \$query"
}
bind .search.s.button <2> {
    # internal search = search in result text
    display $curhistory $query 0 ""
}
set balloonHelp(.search.s.button) [set s($lang)(searchhelp)]
bindtags .search.s.button [list balloon .search.s.button Button all]

menubutton .search.s.searchmeth -text $searchmeth($param(cursearchmeth),name) \
    -menu .search.s.searchmeth.m -indicatoron 1 -anchor c \
    -direction flush -font lfont -width 12 -relief raised
set balloonHelp(.search.s.searchmeth) [set s($lang)(searchmeth)]
bindtags .search.s.searchmeth [list balloon .search.s.searchmeth Menubutton all]
menu .search.s.searchmeth.m -font lfont -tearoff 0

# Wheel mouse bindings for easy scrolling through search methods:
proc next_searchmeth {nextprior} {
    global param searchmeth searchmpos gparam s query
    foreach i $searchmpos {
        if {$nextprior == 1} {     # next
            if {$param(cursearchmeth) < [expr [llength $searchmpos] - 1]} {
                incr param(cursearchmeth)
            } else {
                set param(cursearchmeth) 0
            }
        } else {                    # prior
            if {$param(cursearchmeth) > 0} {
                set param(cursearchmeth) [expr $param(cursearchmeth) - 1]
            } else {
                set param(cursearchmeth) [expr [llength $searchmpos] - 1]
            }
        }
        if $searchmeth($param(cursearchmeth),avail) {
            .search.s.searchmeth config -text $searchmeth($param(cursearchmeth),name)
            .statusBar.lab config -foreground $param(fcolor) \
                    -text "[set s($gparam(lang))(cmd)] $searchmeth($param(cursearchmeth),grepcmd)"
            .statusBar.file config -foreground $param(fcolor) \
                    -text $searchmeth($param(cursearchmeth),dictfile)
            set_opts_errors $param(cursearchmeth)
        #    querydictsearch $query
            after cancel dictsearchquery_onchange
            after $param(autosearchDelay) dictsearchquery_onchange
            break
        }
    }
}

if {$param(isunix) == 1} {
    bind .search.s.searchmeth <Button-4> { 
        next_searchmeth -1    
        debug 8 "B4 in search.s.searchmeth: $param(cursearchmeth) [llength $searchmpos]"
    }
    bind .search.s.searchmeth <Button-5> { 
        next_searchmeth 1    
        debug 8 "B5 in search.s.searchmeth: $param(cursearchmeth) [llength $searchmpos]"
    }
} else {
    bind .search.s.searchmeth <MouseWheel> {
        if {%D > 0} {
            next_searchmeth 1
            debug 8 "B5 in search.s.searchmeth: $param(cursearchmeth) [llength $searchmpos]"
        } else {
            next_searchmeth -1
            debug 8 "B4 in search.s.searchmeth: $param(cursearchmeth) [llength $searchmpos]"
        }
    }
}

if {$tk_version > 8.3} {
    button .search.s.clear -text [set s($lang)(clear)] -font lfont \
    -relief flat -overrelief raised -command {set query ""}
} else {
    button .search.s.clear -text [set s($lang)(clear)] -font lfont \
    -relief raised -command {set query ""}
}
set balloonHelp(.search.s.clear) [set s($lang)(clearhelp)]
bindtags .search.s.clear [list balloon .search.s.clear Button all]

pack .search.s.back .search.s.forw -side left -pady 0 -padx 0
pack .search.s.label -side left
pack .search.s.label.label .search.s.label.mark -side top -pady 0 -padx 0 -fill x
pack .search.s.entry -side left -expand yes -fill x
pack .search.s.searchmeth -side left -pady 5 -padx 5
pack .search.s.button -side left -pady 5
pack .search.s.clear -side left -pady 5 -padx 5


# adjust size of history buttons
set h [expr [winfo reqheight .search.s.label.label] - 5]
if {$h > 0} {
    debug 8 "new history button size: $h"
    .search.s.back configure -height $h -width $h
    .search.s.forw configure -height $h -width $h
}

# Umlaut buttons?
frame .search.u
button .search.u.aumlaut -text "ä" -font lfont -command {.search.s.entry insert insert "ä"} 
button .search.u.oumlaut -text "ö" -font lfont -command {.search.s.entry insert insert "ö"}
button .search.u.uumlaut -text "ü" -font lfont -command {.search.s.entry insert insert "ü"}
button .search.u.bigaumlaut -text "Ä" -font lfont -command {.search.s.entry insert insert "Ä"}
button .search.u.bigoumlaut -text "Ö" -font lfont -command {.search.s.entry insert insert "Ö"}
button .search.u.biguumlaut -text "Ü" -font lfont -command {.search.s.entry insert insert "Ü"}
button .search.u.eszet -text "ß" -font lfont -command {.search.s.entry insert insert "ß"}

pack .search.u.aumlaut .search.u.oumlaut .search.u.uumlaut .search.u.bigaumlaut .search.u.bigoumlaut .search.u.biguumlaut .search.u.eszet -side left

if {$param(umlaut_buttons) == 1} {
    pack .search.u -side top -pady 2 
}

# Search parameters as multiple menus?
    frame .search.opts
    menubutton .search.opts.optword -textvariable wlabel -menu .search.opts.optword.menu \
        -indicatoron 1 -relief raised -anchor c -direction flush -font lfont \
        -width 11
    set balloonHelp(.search.opts.optword) [set s($lang)(bwords)]
    bindtags .search.opts.optword [list balloon .search.opts.optword Menubutton all]
    menu .search.opts.optword.menu -font lfont -tearoff 0
    .search.opts.optword.menu add command -label [set s($lang)(word)(0)] -font lfont -command \
        {set opts(word) 0; set wlabel [set s($lang)(word)(0)]}
    .search.opts.optword.menu add command -label [set s($lang)(word)(1)] -font lfont -command \
        {set opts(word) 1; set wlabel [set s($lang)(word)(1)]}
    set wlabel [set s($lang)(word)($opts(word))]

    menubutton .search.opts.optcase -textvariable clabel -menu .search.opts.optcase.menu \
        -indicatoron 1 -relief raised -anchor c -direction flush -font lfont \
        -width 13
    set balloonHelp(.search.opts.optcase) [set s($lang)(bcase)]
    bindtags .search.opts.optcase [list balloon .search.opts.optcase Menubutton all]
    
    menu .search.opts.optcase.menu -font lfont -tearoff 0
    .search.opts.optcase.menu add command -label [set s($lang)(case)(0)] -font lfont \
        -command {set opts(case) 0; set clabel [set s($lang)(case)(0)]}
    .search.opts.optcase.menu add command -label [set s($lang)(case)(1)] -font lfont \
        -command {set opts(case) 1; set clabel [set s($lang)(case)(1)]}
    
    set clabel [set s($lang)(case)($opts(case))]
    
    menubutton .search.opts.errors -textvariable elabel -menu .search.opts.errors.menu \
        -indicatoron 1 -relief raised -anchor c -direction flush -font lfont \
        -width 9
    set balloonHelp(.search.opts.errors) [set s($lang)(berrors)]
    bindtags .search.opts.errors [list balloon .search.opts.errors Menubutton all]
    menu .search.opts.errors.menu -font lfont -tearoff 0
    
    # set opts(errors) 0
    if {[expr $opts(errors) == -1]} {
        set elabel [set s($lang)(closestmatch)]
    } else {
        set elabel "$opts(errors) [expr $opts(errors) == 1 ? {[set s($lang)(error)]} : {[set s($lang)(errors)]}]"
    }
    
    for {set x 0} {$x < 5} {incr x} {
        set e [expr $x == 1 ? {[set s($lang)(error)]} : {[set s($lang)(errors)]}]
        .search.opts.errors.menu add command -label "$x $e" -font lfont \
            -command "
                set opts(errors) $x; set elabel \"$x $e\""
    }
    .search.opts.errors.menu add command -label [set s($lang)(closestmatch)] -font lfont \
        -command {set opts(errors) -1; set elabel [set s($lang)(closestmatch)]}
    
    
    menubutton .search.opts.regex -textvariable rlabel -menu .search.opts.regex.menu \
        -indicatoron 1 -relief raised -anchor c -direction flush -font lfont \
        -width 13
    set balloonHelp(.search.opts.regex) [set s($lang)(bregex)]
    bindtags .search.opts.regex [list balloon .search.opts.regex Menubutton all]
    menu .search.opts.regex.menu -font lfont -tearoff 0
    .search.opts.regex.menu add command -label [set s($lang)(regex)(0)] -font lfont -command \
        {set opts(regex) 0; set rlabel [set s($lang)(regex)(0)]}
    .search.opts.regex.menu add command -label [set s($lang)(regex)(1)] -font lfont -command \
        {set opts(regex) 1; set rlabel [set s($lang)(regex)(1)]}
    set rlabel [set s($lang)(regex)($opts(regex))]
    
    pack .search.opts.optword .search.opts.optcase .search.opts.errors \
        .search.opts.regex -side left -fill x -padx 2

if {$param(params_as_menu) == 1} {
    pack .search.opts -side top -pady 2
}

####### Results
frame .result 
if {! $mini} {
    # pack .result -side top -fill both -expand yes -padx 0 -pady 0
}

text .result.text -bd 1 -state disabled -wrap none -relief groove \
     -padx 2 -pady 2 -font tfont -width 76 -height 16 \
     -yscrollcommand ".result.yscroll set"  \
     -xscrollcommand [list xscroll .result.xscroll \
        [list grid .result.xscroll  -in .result -row 1 -column 0 -sticky ew]]
 
     # -yscrollcommand [list yscroll .result.yscroll 
     #     [list grid .result.yscroll  -in .result -row 0 -column 1 -sticky ns]] 
 
scrollbar .result.yscroll -orient vertical -command { .result.text yview }
scrollbar .result.xscroll -orient horizontal -command { .result.text xview }
if {$param(isunix)} {          # I like smaller scrollbars
    .result.yscroll configure -width 10 -bd 1
    .result.xscroll configure -width 10 -bd 1
}

grid .result.text -in .result -row 0 -column 0 -sticky news -padx 0 -pady 0 -ipadx 0 -ipady 0
grid .result.yscroll  -in .result -row 0 -column 1 -sticky ns
# grid .result.xscroll  -in .result -row 1 -column 0 -sticky we
# grid .result.yscroll -sticky news
# grid .result.xscroll -sticky news
grid rowconfig    .result 0 -weight 1 -minsize 0
grid columnconfig .result 0 -weight 1 -minsize 0
# grid remove .result.xscroll
# grid remove .result.yscroll
# grid configure .result.text -columnspan 2
grid configure .result.text -rowspan 2


####### Status bar
frame .statusBar

label .statusBar.lab -width 46 -relief sunken -bd 1 -height 1 \
    -text "[set s($lang)(cmd)] $searchmeth($param(cursearchmeth),grepcmd)" \
    -font sfont -anchor w
label .statusBar.file -width 30 -relief sunken -bd 1 -height 1 \
    -font sfont -anchor w -justify right \
    -text $searchmeth($param(cursearchmeth),dictfile)

pack .statusBar.lab  -side left -padx 1 -pady 1 -expand yes -fill x
pack .statusBar.file -side left -padx 1 -pady 1 -expand yes -fill x
# hideStatusBar $param(show_status)

update_searchmeth_menu
set_opts_errors $param(cursearchmeth) 
 
# automatically minimize?
set param(do_automin) [expr {$param(win_prop) == 2 && $param(autominDelay) > 0}]
  
   
# Key bindings
set w .search.s.entry
set t .result.text

bind $w <Return> "dictsearch \$query"
bind $w <Shift-Return> {
    after cancel dictsearchquery
    display $curhistory $query 0 ""}
bind $w <Control-Up>   {history back}
bind $w <Control-Down> {history forward}
bind $w <Escape> {set query ""; .search.s.entry configure -foreground $param(fcolor); Reset 0}
bind $w <Shift-Escape> {set query ""; Reset 1}
bind $w <Control-u> {set query ""; .search.s.entry configure -foreground $param(fcolor); Reset 0}
bind $w <Control-w> {%W selection clear; %W delete [tk::EntryPreviousWord %W insert] insert; .search.s.entry configure -foreground $param(fcolor); Reset 0}
bind $w <Control-BackSpace> {%W selection clear; %W delete [tk::EntryPreviousWord %W insert] insert; .search.s.entry configure -foreground $param(fcolor); Reset 0}

# for autosearch
foreach c {a b c d e f g h i j k l m n o p q r s t u v w x y z 
           A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
           adiaeresis odiaeresis udiaeresis ssharp
           Adiaeresis Odiaeresis Udiaeresis} {

    bind $w <KeyPress-$c> { 
   # problems mit KeyRelease an ^C/^L
        # debug 8 "KeyPress-%K"
        after cancel dictsearchquery; 
        after $param(autosearchDelay) dictsearchquery
    }
}
bind $w <KeyRelease-asterisk> { 
    after cancel dictsearchquery; 
    after $param(autosearchDelay) dictsearchquery
}



# These key bindings look a bit strange: scroll result's text with key bindings
# to the entry. But the entry always has the focus...
# Settings for scrolling with a wheel mouse
# See http://www.inria.fr/koala/colas/mouse-wheel-scroll/
if {$param(isunix)} {
    bind Text <Button-4>         {%W yview scroll -1 units}
    bind Text <Button-5>         {%W yview scroll 1 units}
    bind Text <Shift-Button-4>   {%W yview scroll -5 units}
    bind Text <Shift-Button-5>   {%W yview scroll 5 units}
    bind Text <Alt-Button-4>     {%W yview scroll -1 pages}
    bind Text <Alt-Button-5>     {%W yview scroll 1 pages}
    bind Text <Control-Button-4> {history back}
    bind Text <Control-Button-5> {history forward}
} else {
# for windows
    bind $w <MouseWheel>       {$t yview scroll [expr {-(%D / 120)}] units}
    bind $w <Shift-MouseWheel> {$t yview scroll [expr {-(%D  /120 * 5)}] units}
    bind $w <Alt-MouseWheel>   {$t yview scroll [expr {-(%D / 120)}] pages}
    bind $w <Control-MouseWheel> {if {%D > 0} {history back} else {history forward}}
}

bind $w <Up>          {$t yview scroll -1 units}
bind $w <Down>        {$t yview scroll 1 units}
bind $w <Shift-Up>    {$t yview scroll -5 units}
bind $w <Shift-Down>  {$t yview scroll 5 units}
bind $w <Prior>       {$t yview scroll -1 pages}
bind $w <Next>        {$t yview scroll 1 pages}
bind $w <Home>        {$t yview moveto 0}
bind $w <End>         {$t yview moveto 1.0}
bind $w <Shift-Left>  {$t xview scroll -5 units}
bind $w <Shift-Right> {$t xview scroll 5 units}
bind $w <F1>          helpGeneral
bind $w <Control-s>   {save 0}
bind $w <Control-l>   {save 1}
bind $w <Control-c>   {clipboard_copy_all}
bind $w <Control-q> {
    if {$param(autosave) != 0} { saveOptions }
    exit
}
wm protocol . WM_DELETE_WINDOW {
    if {$param(autosave) != 0} { saveOptions }
    exit
}
wm protocol . WM_SAVE_YOURSELF {
    if {$param(autosave) != 0} { saveOptions }
    exit
}
bind $w <Control-m> sendMail
bind $w <Control-o> {notice $param(noticefile)}
bind $w <Control-n> startNew
bind $w <Control-space> {hideResult -1}
bind $w <Control-Shift-space> {
    set param(show_menu) [expr $param(show_menu) == 1 ? 0 : 1]
    hideMenuBar $param(show_menu) }

# change font on the fly
bind $w <Control-plus>  { change_font 1}
bind $w <Control-minus> { change_font -1}
bind $w <Control-equal> { change_font 0}
bind $w <Control-0> { change_font 0}

bind Text <Double-1> {
    global query tk_version
    if {$tk_version < 8.4} {
        set tkPriv(selectMode) word
        tkTextSelectTo %W %x %y
    } else {
        set tk::Priv(selectMode) word
        tk::TextSelectTo %W %x %y
    }
    catch {%W mark set insert sel.last}
    catch {%W mark set anchor sel.first}
    catch {set q [selection get -displayof %W]}
    if {[string length $q] > 0 && [string compare $query $q]} {
        set query $q 
        dictsearch $query
    }
}

# mouse over text - highlight the line below the mouse pointer
bind dlookup <Motion> {
    global param
    set tkPriv(x) %x
    set tkPriv(y) %y 
    if {$param(hilite)} {
        .result.text tag remove hilite 1.0 end
        if {[string compare [.result.text index "@%x, %y linestart"] "1.0"]} {
            .result.text tag add hilite "@%x, %y linestart" "@%x, %y lineend"
        }
    }
}

bind . <<PasteSelection>> { 
    global query param
    set tkPriv(x) %x
    set tkPriv(y) %y 
    debug 8 "  Event <<PasteSelection>>: "
    if {$param(isunix)} {
        catch {set q [selection get]}
    } else {
        catch {set q [selection get -selection CLIPBOARD]}
    }
    if {[info exists q] && [string length $q] > 0 && [string compare $query $q]} {
         debug 8 "     $q"
        set query $q
        dictsearch $query
    }
}

# Shift + Mouse-2: search for dropped word in current results
bind . <Shift-2> {
    global query param
    set tkPriv(x) %x
    set tkPriv(y) %y
    debug 8 "  Event Shift-Mouse 2: "
    if {$param(isunix)} {
        catch {set q [selection get]}
    } else {
        catch {set q [selection get -selection CLIPBOARD]}
    }
    if {[info exists q] && [string length $q] > 0 && [string compare $query $q]} {
        debug 8 "     $q"
        set query $q
        display $curhistory $query 0 ""
    }
}

# right mouse button == popup menu
bind dlookup <3> {
    debug 8 "  Event <3>: .popup"
    tk_popup .popup %X %Y 
}

# fold/unfold all additional result entries
proc fold_result {} {
    global history_fold curhistory
    debug 8 "  fold_result: $history_fold($curhistory)"
    for {set i 1} {[info exists history_fold($curhistory)($i)]} {incr i} {
        if {$history_fold($curhistory) == 1} {
            set history_fold($curhistory)($i) 1
        } else {
            set history_fold($curhistory)($i) 0
        }
        catch {.result.text.fold$i invoke}
    }
    set history_fold($curhistory) [expr ! $history_fold($curhistory)]
}

bind Text <Control-1> fold_result


# Polling if global selection changes - for "search on text selection"
proc check_selection {} {
    global query param last_selection check_selection_id opts

    debug 16 "check_selection: [clock seconds]"
    set param(check_selection_active) 1
    if {$param(isunix)} {
        catch {set q [selection get]}
    } else {
        catch {set q [selection get -selection CLIPBOARD]}
    }
    if {[info exists q] && [string length $q] > 0} {
        set q_orig $q
        if {$opts(regex) == 0} {         # replace regex characters
            regsub -all {[*|\]\[]} $q {} q
        }
        if {[string length $q] > 0 && \
            [string compare $last_selection $q] && \
            [string compare $last_selection $q_orig] && \
            [string compare $query $q]} {
            debug 2 "New selection: $q"
            set last_selection $q
            set query $q
            if {[llength [info procs dictsearch]]} {
                catch [dictsearch $last_selection]
            }
        }
    }
    set check_selection_id [after 500 check_selection]
    debug 16 "restarting check_selection id = $check_selection_id"
}


bind . <Enter> {
    global query param last_selection
    debug 16 "Enter %W $param(win_prop) $param(do_automin) search_prop = $param(search_prop)"
    if {[string compare %W "."] == 0} {
        focus .search.s.entry
        if {$param(search_prop) == 2} {
            # fri: Why was that here?
            # catch [check_selection]
            debug 16 "cancelling check_selection [after info]"
            set param(check_selection_active) 0
            after cancel check_selection
        }
        if {$param(search_prop) == 1} {
            # Search when we have Focus and a selection
            if {$param(isunix)} {
                catch {set q [selection get]}
            } else {
                catch {set q [selection get -selection CLIPBOARD]}
            }
            if {[info exists q] && [string length $q] > 0} {
                if {$opts(regex) == 0} {         # replace regex characters
                    regsub -all {[*|\]\[]} $q {} q
                }
                if {[string length $q] > 0 && \

                    [string compare $last_selection $q] && \
                    [string compare $query $q]} {
                    debug 8 " New selection entered: $q"
                    set last_selection $q
                    set query $q
                    catch {[dictsearch $last_selection]}
                }
            }
        }
        if {$param(win_prop) == 1 || $param(do_automin) == 1} {
            # full window when focus in
            hideResult 1
        }
        if {$param(do_automin) == 1 && $param(win_prop) == 2 && $param(autominDelay) > 0} {
            debug 2 " cancelling automatically minimize <Enter>"
            set param(do_automin) 0
            after cancel {hideResult 0}
        }    
    }
}

bind . <Leave> {
    global param
    debug 16  "Leave %W"
    if {[string compare %W "."] == 0} {
        # remove highlight from line
        .result.text tag remove hilite 1.0 end
        if {$param(search_prop) == 2} {
            # poll selection
            if {$param(check_selection_active) == 0} {
                set check_selection_id [after 500 check_selection]
                debug 16 "Leave .: Started check_selection, id = $check_selection_id"
            }
        }
    }
}

bind . <FocusOut> {
    global param
    debug 16  "FocusOut %W"
    if {[string compare %W "."] == 0} {
        if {$param(win_prop) == 1} {
            # mini window when focus out
            hideResult 0
        }
        if {$param(win_prop) == 2 && $param(autominDelay) > 0 &&
            $param(show_result) == 1} {
            set param(do_automin) 1
            debug 2 " automatically minimize after  $param(autominDelay) ms (FocusOut)"
            after $param(autominDelay) {hideResult 0}
        }    
    }
}

proc catch_resize {} {
    global param curhistory history_result
    debug 8  "catch_resize"
    # update

    if { $curhistory > 0 && [string length $history_result($curhistory)] > 0} {
        display $curhistory "" 2 ""
    }
    scan [wm geometry .] {%dx%d+} param(width) param(height)
    debug 8 " catch_resize - new size: $param(width) x $param(height)"
}

# catch resize event to redisplay result text
bind dlookup <Configure> catch_resize

# bind .search.s.entry <Delete> {set query ""}

bindtags .search.s.entry [list .search.s.entry Entry all]

# set tags for result text
if {[winfo depth .] > 1} {      # Color display
    set cols [shadeColor $param(fcolor) $param(bcolor)]
    set param(shadedcolor) [lindex $cols 0]
    set param(highcolor) [lindex $cols 1]
    set param(errcolor) [lindex $cols 2]
    set param(hicolor) [lindex $cols 3]
    .result.text configure -selectbackground $param(fcolor) -selectforeground $param(bcolor) -selectborderwidth 0
    .result.text tag configure bg1 -background $param(shadedcolor)
    .result.text tag configure matchfg -foreground $param(highcolor)
    .result.text tag configure search -background $param(highcolor) -foreground $param(bcolor)
    .result.text tag configure u -background $param(fcolor) -foreground $param(bcolor)
    .result.text tag configure hilite -background $param(hicolor)
    .result.text tag configure aux -font ifont
    .result.text tag configure ipa -font ipafont
} else {
    set param(shadedcolor) white
    set param(highcolor) white
    .result.text tag configure bg1 -background $param(shadedcolor) -foreground black 
    .result.text tag configure matchfg -background black -foreground white
    .result.text tag configure search -background black -foreground white
    .result.text tag configure u -underline 1
    .result.text tag configure hilite -underline 1
    .result.text tag configure aux -font ifont
}

if 0 {
# commented out
if {![info exists grepcmds(agrep)]} {
    .result.text configure -state normal
    .result.text insert end [set s($lang)(noagrep)]
    .result.text insert end $gparam(grepcmd)
    .result.text configure -state disabled
}
}

setSearchBg $param(shadedcolor)

if ($mini) {
    wm geometry . {}
    hideResult 0
    set balloonHelp(.search.l.logo) [set s($lang)(normalsize)]
    .popup entryconfigure 7 -label [set s($lang)(normalsize)]
    update
        if [info exists param(width)] {
            set w $param(width)
        } else {
            set w [winfo width .search]
        }
        debug 8 "  setting geometry: ${w}x[winfo height .search]"
        wm geometry . "${w}x[winfo height .search]"
        # wm geometry . {}
} else {
    wm geometry . {}
    update
    hideResult 1
}

# automatically minimize?
if {$param(win_prop) == 2 && $param(autominDelay) > 0} {
    debug 2 "  automatically minimize after $param(autominDelay) ms (start)"
    set param(do_automin) 1
    after $param(autominDelay) {hideResult 0}
}

# Check selection?
if {$param(search_prop) == 2} {
    # get current selection
    if {$param(isunix)} {
        catch {set q [selection get]}
    } else {
        catch {set q [selection get -selection CLIPBOARD]}
    }
    if {[info exists q] && [string length $q] > 0} {
        set last_selection $q
    }

    # poll for new selection
    if {$param(check_selection_active) == 0} {
        after 500 check_selection
    }
}

update
set geo [wm geometry .]
scan $geo {%dx%d+%d+%d} w h x y
debug 8 "toplevel geometry: $geo, winfo: [winfo width .] [winfo height .] [winfo x .] [winfo y .], correcting height: $param(add_geom_height)"

if {! $mini} {
    set param(width) $w
    set param(height) $h
}

if {[string length $query] == 0 && ! $mini} {
    # welcome message if not started with search query and not mini size
    welcome 1
}
bindtags .result.text {Text . all dlookup}

# Always the focus to the search entry:
focus .search.s.entry

# }
# mainWindow {}

#####################################

# Handling of external processes
proc ExecCmd {cmd stderr_to_stdout} {
    global proc lines param

    debug 1 "ExecCmd $cmd $stderr_to_stdout"
    if {$proc(pid) > 0} {
        .statusBar.lab config -foreground $param(errcolor) -text \
            "Search process is still running. Wait or hit Escape."
        return 1
    }
    if {$stderr_to_stdout == 1 && $param(iswin) == 0} {
        set cmd [concat $cmd {2>@stdout}]
    }
    set lines {}
    if [catch {set proc(pipe) [open "|$cmd" r+]} err] {
        if [string match "child process exited abnormally" $err] {
            .statusBar.lab config -foreground $param(errcolor) -text "[set s($lang)(noresults)] $query"
        } else {
            .statusBar.lab config -foreground $param(errcolor) -text $err
        }
        return 1
    }
    debug 4 "Pipe: $proc(pipe)"
    set proc(pid) [pid $proc(pipe)]
    set proc(processlist) [list $proc(pid) $cmd]
    # fconfigure $proc(pipe) -buffering none -blocking 0
    fileevent $proc(pipe) readable "CmdOut"
    return 0
}

proc CmdOut {} {
    global proc sigchld lines param searchmeth

    debug 2 "CmdOut"
    set r1 [catch {eof $proc(pipe)} res]
    if {$r1 || $res} {
        debug 4 "  CmdOut: End of $proc(pipe): $proc(processlist)"
        catch {close $proc(pipe)} err
        debug 4 "  CmdOut: Close pipe: $err"
        set sigchld 1
        # mark as finished
        set proc(processlist) {}
        set proc(pid) -1
        return
    }
    # else read from the pipe
    set line [read $proc(pipe)]
    if {[llength $lines] > 10 * $searchmeth($param(cursearchmeth),maxresults)} {
        # Reset
        return
    }
    # if {$line != ""}i
    foreach l [split $line "\n"] {
        lappend lines $l
        debug 4 "  CmdOut: read [llength $lines] .$l."
        if {[llength $lines] > 10 * $searchmeth($param(cursearchmeth),maxresults)} {
            debug 4 "  CmdOut: more than $searchmeth($param(cursearchmeth),maxresults) read, stopping"
            Reset 0
            break
        }
    }
}

# handle queries with umlauts - make queries to find also other spellings
proc umlautquery {query style} {
    debug 8 "umlautquery $query"
    if {[string length $query] < 1} {return ""}
    set q $query
    lappend Q $q
    if {[regsub -all {ae} $q {ä} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {oe} $q {ö} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {ue} $q {ü} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {A[Ee]} $q {Ä} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {O[Ee]} $q {Ö} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {U[Ee]} $q {Ü} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {ss} $q {ß} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
    if {[regsub -all {ß} $q {ss} q] > 0 && [lsearch $Q $q] == -1} {lappend Q $q}
     
    if {$style == "agrep"} {
        set ret [join $Q {,}]
        # new agrep ...
        # set ret [join $Q {|}]
    } else {
        set ret  [join $Q {|}]
        if {[llength $Q] > 1} {set ret "($ret)"}
    }
    debug 8 " -> $ret"
    return $ret
}

# Thanks to Holger Trapp <hot@hrz.tu-chemnitz.de>
# enforce loading the Tcl procedures "tcl_wordBreakBefore" and
# "tcl_wordBreakAfter" by calling them with senseless args.
# Now the global strings "tcl_nonwordchars" and "tcl_wordchars" are initialized
# and we can modify them as needed to specify the chars belonging or not
# belonging to words respectively
### No need on Unix for this:

# if {$param(iswin) == 1} {
    tcl_wordBreakBefore "" 0
    tcl_wordBreakAfter "" 0
    # set tcl_wordchars {[a-zA-Z0-9_äöüÄÖÜß]}
    # set tcl_nonwordchars {[^a-zA-Z0-9_äöüÄÖÜß]}
    set tcl_wordchars "\\w"
    set tcl_nonwordchars "\\W"

# }

### internal search - search in dict file without an external grep
# Thanks to Jens Poenisch <jens@ruessel.in-chemnitz.de>

array set internal_search_Dict {}
array set internal_search_init {}

proc internal_search {query dictfile max} {
    global internal_search_init internal_search_Dict internal_search_dict
    global param proc opts tcl_nonwordchars
    debug 4 "internal_search $query $dictfile $max"

    if {! [info exists internal_search_init($dictfile)]} {
        set nr [array size internal_search_init]
        incr nr
        debug 4 "Initialising $dictfile ($nr) ..."
        set s0 [clock seconds]
        .statusBar.lab config -foreground $param(fcolor) \
            -text "Initializing $dictfile ..."
        update idletasks
        set fd [open $dictfile r]
        fconfigure $fd -buffersize 1024000
        set Text [read $fd]
        close $fd

        # exact case
        set internal_search_Dict($nr) [split $Text \n]
        # lower case
        set text [string tolower $Text]
        set internal_search_dict($nr) [split $text \n]

        set internal_search_init($dictfile) $nr

        .statusBar.lab config -foreground $param(fcolor) \
            -text "[expr [clock seconds] - $s0] sec"
        debug 4 "done: [expr [clock seconds] - $s0] sec"
    }
    set f 0
    set num 0
    set result {}
    set proc(pid) 0
    set search {-regexp}
    if {$opts(regex) == 0} {         # simple query
        regsub -all {\*} $query {.*} query
    }
    if {$opts(case) == 0} {
        set query [string tolower $query]
    }
    if {$opts(word) == 0} {
        set searchquery "(^|.*${tcl_nonwordchars})${query}(${tcl_nonwordchars}.*|$)"
    } else {
        set searchquery "${query}"
    }
    # case exact ?
    set in $internal_search_init($dictfile)
    if {$opts(case)} {
        set d $internal_search_Dict($in)
    } else {
        set d $internal_search_dict($in)
    }
    debug 8 "searchquery = $searchquery in $in"
    while {$proc(pid) == 0 && $num <= $max && \
           [set i [lsearch -regexp [lrange $d $f end] $searchquery]] >= 0} {
        update
        lappend result [lindex $internal_search_Dict($in) [expr $f+$i]]
        debug 4 "$num: [lindex $internal_search_Dict($in) [expr $f+$i]]"
        set f [expr $f+$i+1]
        incr num
    }
    debug 4 "internal_search ended - $num results"
    return $result
}

proc querydictsearch {q} {
    global query
    debug 1 "querydictsearch $q"
    if {[string length $q] > 0} {
        set query $q
        return [dictsearch $query]
    }
    return 0
}

proc dictsearch {query args} {
    global param gparam searchmeth result opts
    global curhistory inshistory 
    global history_result history_query history_searchm history_pos history_fold
    global s logoanim defaultcursor lines sigchld

    debug 1 "dictsearch $query"
    set lang $gparam(lang)

    # cancel autosearch
    after cancel dictsearchquery

    # disable auto minimize
    if {$param(do_automin) == 1 && $param(win_prop) == 2 && $param(autominDelay) > 0} {
         debug 2 " cancelling automatically minimize (dictsearch)"
         # set param(do_automin) 0
         after cancel {hideResult 0}
    }    

    # starts with / -> internal search
    if {[regexp {^/} $query]} {
        regsub {^/} $query {} iquery
        debug 2 "  query starts with / -> internal search"
        # .search.s.entry delete 0 end
        # .search.s.entry insert 0 $query
        # set history_pos($curhistory) [lindex [.result.text yview] 0]
        set history_pos($curhistory) [.result.text index @0,0]
        display $curhistory $iquery 0 ""
        return 2
    }

    # search method specified
    if [llength $args] {
        set c [lindex $args 0]
        if [info exists searchmeth($c,name)] {
            set param(cursearchmeth) $c
            .search.s.searchmeth configure -text $searchmeth($c,name)
            set_opts_errors $c
        }
    }
    set curr $param(cursearchmeth)
    debug 1 "  using search method $curr ($searchmeth($curr,name))"

    if {[string length $searchmeth($curr,dictfiles)] <= 0} {
        .statusBar.lab config -foreground $param(errcolor) -text [set s($lang)(nodictfile)]
        return 2
    }

    # clean up query
    # remove spaces and so at the beginning and the end
    set orig_query $query
    regsub -all "^\[ ,;:+'\n\t\]*" $query {} query
    regsub -all "\[ ,:-;'\n\t\]*$" $query {} query
    # remove duplicate spaces
    regsub -all {   *} $query { } query
    # remove newline, tab, \
    regsub -all "\[\n\r\t\]$" $query {} query
    regsub -all "\[\n\r\t\]" $query { } query
    regsub -all {\\$} $query {} query
    if {$opts(regex) == 0} {
        regsub -all {\.$} $query {} query
        regsub -all {~} $query {} query
    }

    if {[string match "*spell" $searchmeth($curr,grepcmd)]} {
        set squery $query
        regsub -all {ä} $squery {a"} squery
        regsub -all {Ä} $squery {A"} squery
        regsub -all {ö} $squery {o"} squery
        regsub -all {Ö} $squery {O"} squery
        regsub -all {ü} $squery {u"} squery
        regsub -all {Ü} $squery {U"} squery
        regsub -all {ß} $squery {s"} squery
    } else {
        regsub -all {"a} $query {ä} query
        regsub -all {"A} $query {Ä} query
        regsub -all {"o} $query {ö} query
        regsub -all {"O} $query {Ö} query
        regsub -all {"u} $query {ü} query
        regsub -all {"U} $query {Ü} query
        regsub -all {"s} $query {ß} query
        regsub -all {"}  $query "" query
        set squery $query
    }
    if {[string compare $orig_query $query]} {
        # if query changed, display it
        .search.s.entry delete 0 end
        .search.s.entry insert 0 $query
    }

    if {[string length $squery] < $searchmeth($curr,minlength)} {
        if {$param(autosearch_active) == 0} {
            .statusBar.lab config -foreground $param(errcolor) \
                -text [set s($lang)(tooshort)]
        }
        return 2
    }
    if {[string length $squery] > $searchmeth($curr,maxlength)} {
        if {$param(autosearch_active) == 0} {
            .statusBar.lab config -foreground $param(errcolor) -text \
                "[set s($lang)(toolong)] ([string length $squery], max. $searchmeth($curr,maxlength))"
        }
        return 2
    }

    # escape shell meta chars -> \
    regsub -all {([]\[\{\} `&$])} $squery {\\\1} squery
    regsub -all {([<>|])} $squery {\\\\\1} squery


    # evaluate options
    set isgrep 0
    set isspell 0
    set isdict 0
    set opt $searchmeth($curr,grepopts)
    set internal 0
    set q $query
    set cmd {}
    set stderr_to_stdout 1

    if [string match "internal_*" $searchmeth($curr,grepcmd)] {
        # internal search
        set cmd [concat $searchmeth($curr,grepcmd) \"$query\" $searchmeth($curr,dictfiles) $searchmeth($curr,maxresults)]
        set internal 1
        # for sorting
        set isgrep 1
    } elseif {[string match "*grep" $searchmeth($curr,grepcmd)]} {
        # grep family
        set isgrep 1
        if {$opts(word) == 0 && ![regexp {[.| ]} $squery] && $opts(errors) != -1} {
            # words only search - makes no sense if search string contains
            # white space, or when "best match" used
            set opt "$opt -w"
        }
        if {$opts(case) == 0} {
            set opt "$opt -i"
        }
        if ($opts(errors)) {
            if {$opts(errors) == -1} {
                set opt "$opt -B -y"
            } else {
                set opt "$opt -$opts(errors)"
            }
        }
        if {$opts(regex) == 0} {
            if [string match "agrep*" $searchmeth($curr,grepcmd)] {
                # prepare simple pattern for agrep
                regsub -all {\*} $squery "#" squery
                # delete lonesome + at the end
                regsub -all {\+$} $query "" query
                regsub -all {\+$} $squery "" squery
                # AND: + -> ;
                regsub -all { *\+ *} $squery ";" squery
                # Umlaut

                set squery [umlautquery $squery "agrep"]
            } else {
                # prepare simple pattern for other grep cmd: * -> .*
                regsub -all {\*} $squery ".*" squery
                set squery [umlautquery $squery "egrep"]
            }
            # q is for priority sorting
            regsub -all {[[\*+)(]} $query "" q
        }
        debug 8 "    query = $query, squery = $squery"

        set opt "$opt -e"
        set cmd [concat "$searchmeth($curr,grepcmd) $opt \"$squery\" $searchmeth($curr,dictfiles)"]
    } elseif {[string match "*spell" $searchmeth($curr,grepcmd)]} {
        # spell family
        set isspell 1
        set cmd [concat "echo \"$squery\" | $searchmeth($curr,grepcmd) $opt"]
    } elseif {[string match "*fortune" $searchmeth($curr,grepcmd)]} {
        # fortune
        set stderr_to_stdout 0
        if {[string length $squery] > 0} {
            # fortune with pattern
            if {$opts(case) == 0} {
                set opt "$opt -i"
            }
            if {$opts(word) == 0} {
                # words only search - add a space after word...
                set squery "$squery\[ !?.,\]"
            }
            set opt "$opt -m \"$squery\""
        }
        set cmd [concat "$searchmeth($curr,grepcmd) $opt"]

    } else {
        # this is for dict: 
        set isdict 1
        set strategy {}
        if {$opts(regex) == 1} {
            set strategy "-s re"
        } elseif {$opts(word) == 1 || [regexp { } $squery]} {
            regsub -all {\*} $squery "" squery
            set strategy "-s substring"
        } elseif {[regsub -all {\*$} $squery "" squery]} {
            set strategy "-s prefix"
        }
        # what to do with these?
        # setting more than one search strategy is useless
        if {$opts(errors) >= 1} {
            set opt "$opt -s lev"
        } elseif {$opts(errors) == -1} {
            set opt "$opt -s soundex"
        }

        if {$strategy != ""} {
            set opt "$opt $strategy"
        }
        set cmd [concat "$searchmeth($curr,grepcmd) $opt -- \"$squery\""]
    }

    set starttime [clock clicks -milliseconds]
    .statusBar.lab config -foreground $param(fcolor) -text "$cmd"

    . configure -cursor watch
    .result.text configure -cursor watch
    .search.s.entry configure -cursor watch
    update
    
    # Suche!
    set res ""
    set logoanim 1
    animlogo .search.l.logo

    debug 1 "dictsearch: Starting $cmd"
    if ($internal) {
        set lines [eval $cmd]
    } else {
        set sigchld 0
        if {[ExecCmd $cmd $stderr_to_stdout] == 0} {
            tkwait variable sigchld
        } else {
            # wait a bit - allow to see the error message
            update idletasks
            after 2000
        }
    }
    # ok, read results
    update idletasks
    set resl {}
    set c 0
    foreach line $lines {
    # foreach line [split $lines "\n"]
        update idletasks
        incr c
        debug 2 "dictsearch: result $c: $line." 
        if {!$isspell && [regexp "^#" $line]} {      # skip comments
            continue
        }
        if {$isdict && [regexp "^No (definitions|matches) found for " $line]} {
            continue
        }
        set p 0
        # sorting of *grep
        if {$isgrep} {
            if {$line == ""} {continue}
            if [string match "Grand Total*" $line] {
                # get rid of Windows agrep's last line ...
                continue
            }
            # find good matches (word at beginning, exact order etc.)
            #  remove alls (..) [..] {..}
            regsub -all { \{[^.\}]*\}} $line "" pline
            regsub -all { \([^.\)]*\)} $pline "" pline
            regsub -all { \[[^\]]*\]} $pline "" pline
            # debug 8 "$line\n$pline"

            if {[regexp {[ +]} $query]} {       # search words with spaces
                set p [regexp -nocase -- $q $pline]
            } else {
                set ml [regexp -all {\|} $line]
                if {$ml > 0} {                  # multiline result
                    set p 0
                    # Anfang + 100
                    if {[regexp -nocase ":: (to )?${q}(;.*| )\\|" $pline] ||
                        [regexp -nocase "^${q}(;| ).*\\|.* ::" $pline] } {
                        set p [expr $p + 100 + $ml]
                    # 1. Zeile
                    } elseif {[regexp -nocase ":: \[^|\]*${q}.*\\|" $pline] ||
                        [regexp -nocase "^\[^|\]*${q}.*\\|.* ::" $pline] } {
                        set p $ml
                    }
                } else {
                    set p 2
                    # set p [expr [string length $pline] - [string first $q $pline]]
                    # Anfang + 100
                    if {[regexp -nocase ":: (to )?${q}(;|$)" $pline] ||
                        [regexp -nocase "^${q}(;| ::)" $pline]} {
                        set p [expr $p + 100]
                    } elseif {[regexp -nocase "; ${q}(;|$)" $pline]} {
                        # Einzelwort
                        set p [expr $p + 80]
                    }
                    # Abkürzung + 10
                    if {[regexp { : } $pline]} {set p [expr $p + 10]}
                }
            }
            debug 8 "dictsearch: prio $p: $line"
        }
        lappend resl [list $p $line]
    }
    debug 8 "dictsearch: prio sorting ..."
    set res {}
    set first 1
    foreach l [lsort -decreasing -integer -index 0 $resl] {
        if {$first == 1} {set first 0} else {set res "$res\n"}
        set res "$res[lindex $l 1]"
    }
    debug 8 "dictsearch: prio sorting done"
    if [string length $res] {
        # results found
        .search.s.entry configure -foreground $param(fcolor)
        if {$inshistory >= $param(maxhistory)} {
            set inshistory 1
        } else {
            incr inshistory
        }
        .search.s.forw configure -state disabled
        .popup entryconfigure 1 -state disabled
        if {$curhistory != 0} {
            .search.s.back configure -state normal
            .popup entryconfigure 0 -state normal
            # mark the current scroll position
            #set history_pos($curhistory) [lindex [.result.text yview] 0]
            set history_pos($curhistory) [.result.text index @0,0]
        }
        set curhistory $inshistory
        set history_query($inshistory) $query
        set history_searchm($inshistory) $curr
        set history_result($inshistory) $res
        set history_pos($inshistory) 0.0
        set history_fold($inshistory) $searchmeth($curr,foldedresult)
	    set endtime [clock clicks -milliseconds]
        display $inshistory "" 1 " [expr {$endtime - $starttime}] msec"
        set ret 0
    } else {
        # no results found
        # .search.s.entry delete 0 end
        # .search.s.entry insert 0 $query
        # .search.s.entry selection range 0 [string length $query]
        .statusBar.lab config -foreground $param(errcolor) -text \
            "[set s($lang)(noresults)] $query"
        .search.s.entry configure -foreground $param(errcolor)
        .result.text configure -state disabled
        set ret 1
    }

    catch {close $in}
    after 400 {
        after cancel animlogo .search.l.logo
        .search.l.logo configure -image "logo1"
    }

    . configure -cursor $defaultcursor
    .result.text configure -cursor $defaultcursor
    .search.s.entry configure -cursor $defaultcursor
    return $ret
}

proc dictsearchquery {} {
    global query param
    debug 2 "dictsearchquery $query"
    if {$param(autosearch) == 0} return
    set param(autosearch_active) 1
    # set r [dictsearch $query]
    if {[dictsearch $query] == 1} {
        # no result -> try appending *
        debug 2 "dictsearchquery $query*"
        dictsearch "$query*"
    }
}

proc dictsearchquery_onchange {} {
    global query param curhistory history_query history_searchm
    debug 2 "dictsearchquery_onchange $query - $curhistory"
    if {$param(autosearch) == 0} return
    if {[string length $query] == 0} return
    if {[info exists history_query($curhistory)] && 
       $history_query($curhistory) == $query && $history_searchm($curhistory) == $param(cursearchmeth)} { 
      debug 2 "query and search method identical - returning"
      return
    }
    set param(autosearch_onchage_active) 1
    # set r [dictsearch $query]
    if {[dictsearch $query] == 1} {
        # no result -> try appending *
        debug 2 "dictsearchquery_onchange $query*"
        dictsearch "$query*"
    }
}

# display: shows search results:
#      num    - show result for number in history
#      search - highlight this string in result
#      status - update status line, remove scrollbars?
#               1 = from new search, 2 = from history
#      extra  - some extra status info

proc display {num search status extra} {
    global searchmeth maxresults param gparam s
    global history_query history_searchm history_result history_pos history_fold

    debug 1 "display num = $num search = $search status = $status extra = $extra"

    # make result visible
    hideResult 1
    wm deiconify .

    if ![info exists history_query($num)] {
        return
    }
    if ![info exists history_pos($num)] {
        set history_pos($num) 0.0
    }
    set history_spos $history_pos($num);
    debug 4 "history_spos = $history_spos"

    set lang $gparam(lang)
    set count 0
    set foldcount 0
    set more ""
    set shape 0

    if {[string length $search] == 0 && $status != 1} {
        .search.s.entry delete 0 end
        .search.s.entry insert 0 $history_query($num)
    }

    # selection to the query in search entry when no other selection active
    if {$param(isunix)} {
        catch {set q [selection get]}
    } else {
        catch {set q [selection get -selection CLIPBOARD]}
    }
    if {$param(autosearch_active) == 0 &&
        (![info exists q] ||
        ([string length $q] > 0 && 
         [string compare $q $history_query($num)] == 0))} {
         debug 2 "query selection exported: $history_query($num)"
         # debug 2 "query selection exported: $q - $history_query($num)"
        .search.s.entry configure -exportselection 1
        .search.s.entry selection range 0 end
    } else {
         debug 2 "query selection NOT exported: $history_query($num)"
        .search.s.entry configure -exportselection 0
        .search.s.entry selection range 0 end
    }

    # search pattern for marking
    regsub -all {[,+]} $history_query($num) "|" mquery
    regsub -all {[[*+?)(|$]} $mquery "" mquery
    regsub -all {^-} $mquery "" mquery
    regsub -all {  } $mquery " " mquery
    debug 8 " query = $history_query($num), mquery = $mquery"

    set t .result.text
    $t configure -state normal
    $t delete 0.0 end
    # remove scrollbars
    if {$status > 0} {
        grid forget .result.xscroll
        # grid forget .result.yscroll
        # grid configure .result.text -columnspan 2
        grid configure .result.text -rowspan 2
    }

    # compute tab stop in the middle
    # set width [$t cget -width]
    set width [winfo width $t]
    set w [expr round(($width / 2) - 2)]
    $t configure -tabs $w


    if {[string compare $searchmeth($history_searchm($num),language1) ""] || \
        [string compare $searchmeth($history_searchm($num),language2) ""]} {
        $t insert end \
        "$searchmeth($history_searchm($num),language1)\t  $searchmeth($history_searchm($num),language2)\n" u
    }

    set isdict [expr [string compare $searchmeth($history_searchm($num),grepcmd) "dict"] ? 0 : 1]
    set isfortune [string match "*fortune" $searchmeth($history_searchm($num),grepcmd)]
    set isspell [string match "*spell" $searchmeth($history_searchm($num),grepcmd)]
    if {$isspell} {     ; # an empty line ...
        $t insert end "\n"
    }
    set spell_version {}
    set ftext 0
    set ffirst 1
    set xscroll 0

    # for each line
    foreach l [split $history_result($num) "\n"] {
        if {!$isspell && [regexp "^#" $l]} {      # skip comments
            continue
        }
        if {$count >= $searchmeth($history_searchm($num),maxresults)} {
            set more [set s($lang)(more)]
            break
        }
        if {$isdict == 1} {
            # dict - Find a "NUM definition found" l
            if {[regexp {^([0-9]+) definitions? found} $l b c]} {
                set count $c
                continue
            }
        } elseif {$isfortune == 1} {
            # fortune 
            if {! $ftext && [regexp {^$} $l]} {
                continue
            }
            if {[regexp {^\(.*\)$} $l]} {
                set ftext 0
                continue
            }
            if {[regexp "^%$" $l]} {
                set l ""
                if {$searchmeth($history_searchm($num),shapedresult)} {
                    set shape [expr ! $shape]
                }
                if $ftext {
                    incr count
                    $t insert end "\n"
                }
                continue
            } else {    
                # fortune text
                # substitute tabs
                if $ffirst {
                    incr count
                    set ffirst 0
                    $t insert end "\n"
                }
                set ftext 1
                regsub "\t" $l "    " l
            }
        } elseif {$isspell == 1} {
          # ispell -a results:
          # fist line: @(#) Version
          # * ok
          # + <root word>
          # - <concatenation>,
          # & <original>  <count>  <offset>:  <miss>,  <miss>, ..., <guess>, ...
          # ? <original> 0 <offset>: <guess>, <guess>, ...
          # # <original> <offset>

            if {[regexp {^@\(#\) (.+)} $l b spell_version]} {
                continue
            } elseif {[regexp {^$} $l]} {
                continue
            } elseif {[regexp {^\*} $l]} {
                set l [set s($lang)(correct)]
            } elseif {[regexp {^\+} $l]} {
                regsub {^\+} $l "[set s($lang)(root)]:" l
            } elseif {[regexp {^\#} $l]} {
                set l [set s($lang)(nosuggestion)]
            } else {
                regsub {.+: } $l "[set s($lang)(suggestion)]: \n" l
                # wrap results
                regsub -all {(.{40}[^,]*), } $l "\\1\n" l
                regsub -all {\n} $l "\n    " l

                # regsub -all {, } $l "\t\n" l
            }
            regsub -all {a"} $l {ä} l
            regsub -all {A"} $l {Ä} l
            regsub -all {o"} $l {ö} l
            regsub -all {O"} $l {Ö} l
            regsub -all {u"} $l {ü} l
            regsub -all {U"} $l {Ü} l
            regsub -all {s"} $l {ß} l

            incr count 
        } else {
            # not dict: 1 line == 1 match
            incr count 
            # ignore <...> - old/wrong spelling
            regsub -all {<[^>]*>} $l {} l
        }

        if {$searchmeth($history_searchm($num),shapedresult)} {
            if {$isdict == 1} {
                if {[regexp "^From " $l]} {
                    set shape 1
                } else {
                    set shape 0
                }
            } elseif {! $isfortune} {
                if {[expr $count % 2]} {
                    set shape 1
                } else {
                    set shape 0
                }
            }
        }
        set bgtag [expr {$shape == 1 ?  {bg1 } : {}}]

        if {[string compare $searchmeth($history_searchm($num),separator) ""] && \
            [regexp "$searchmeth($history_searchm($num),separator)" $l]} {
            regsub "$searchmeth($history_searchm($num),separator).*" $l "" lang1
            regsub ".*$searchmeth($history_searchm($num),separator)" $l "" lang2
            if {[regexp {\|} "$lang1"]} {
                # contains additional entries: separate on different lines
                set l1 [split $lang1 |]
                set l2 [split $lang2 |]
                incr foldcount
                set tag "vis$foldcount"
                if {! [info exists history_fold($num)($foldcount)]} {
                    set history_fold($num)($foldcount) $history_fold($num)
                }
                $t tag configure $tag -elide [set history_fold($num)($foldcount)]

                for {set i 0} {$i < [llength $l1]} {incr i} {
                    if {$i == 0} {    # first = main entry
                        $t insert end "[lindex $l1 $i]\t" $bgtag
                        set cmd "$t tag configure $tag -elide \[expr \[set history_fold($num)($foldcount)\]\]"
                        checkbutton $t.fold$foldcount -image minus -selectimage plus \
                           -variable history_fold($num)($foldcount) -indicatoron 0 \
                           -bd 0 -width 8 -height 8 -command $cmd
                        $t window create end -window $t.fold$foldcount
                        $t insert end " [lindex $l2 $i]\n" $bgtag
                        # search word within main entry?
                        if {[string length $mquery] > 0 &&
                            ([regexp -nocase "$mquery" [lindex $l1 $i]] ||
                             [regexp -nocase "$mquery" [lindex $l2 $i]])} {
                            set foundfirst 1
                            debug 8 "found $mquery first"
                        } else {
                            set foundfirst 0
                            debug 8 "NOT found $mquery first"
                        }
                    } elseif {(! $foundfirst) && [string length $mquery] > 0 && 
                              ([regexp -nocase "$mquery" [lindex $l1 $i]] ||
                               [regexp -nocase "$mquery" [lindex $l2 $i]])} {
                        # search word in additional line
                        $t insert end "[lindex $l1 $i]\t    [lindex $l2 $i]\n" $bgtag
                    } else {          # additional entry
                        $t insert end "[lindex $l1 $i]\t    [lindex $l2 $i]\n" "$bgtag $tag"
                    }
                }
            } else {
                $t insert end "$lang1\t  $lang2\n" $bgtag
            }
        } else {
            $t insert end "$l\n" $bgtag
        }
    }
    # selection colors wins over other tags colors
    $t tag raise sel

    if {$status > 0} {
        set erg [expr $count == 1 ? {[set s($lang)(result)]} : {[set s($lang)(results)]}]
        if {$isdict == 1 && $count == 0} {
            set count "??"
        }
        .statusBar.lab config -foreground $param(fcolor) -text "$count $erg $more $extra"
        if {$isspell == 1} {
            .statusBar.file config -foreground $param(fcolor) -text $spell_version
        }
    }
    # find and mark match pattern
    if {[string length $mquery] > 0} {
        debug 4 "   find and mark match pattern: >$mquery<"
        set cur 1.0
        while 1 {
            set cur [.result.text search -nocase -count length -regexp -- $mquery $cur end]
            if {$cur == ""} {
                break
            }
            .result.text tag add matchfg $cur "$cur + $length char"
            set cur [.result.text index "$cur + $length char"]
        }
    }

    # search pattern ?
    if {[string length $search] > 0} {
        debug 4 "   find and mark search pattern: >$search<"
        # remove special chars
        regsub -all {\*} $search {} search
        if {[string length $search] <= 0} {
            return
        }
        if {$status > 0 || ![info exists history_spos] || $history_spos == 0} {
            set history_spos 1.0
        }
        set found 0
        set first {}
        # mark search words
        # start looking at current position
        set now [expr $history_spos + 1.0]
        set cur 1.0
        while 1 {
            set cur [.result.text search -nocase -count length -exact -- $search $cur end]
            if {$cur == {}} {
                break
            }
            if {$first == {}} {
                set first $cur
            }
            .result.text tag add search $cur "$cur + $length char"
            set new [.result.text index "$cur + $length char"]
            if {$found == 0} {
                if {$status == 0 && $history_spos != 1.0} {
                    if [.result.text compare $cur > $now] {
                        set history_spos $new
                        set found 1
                    }
                } else {
                    set history_spos $new
                    set found 1
                }
            }
            set cur $new
        }
        .statusBar.lab configure -foreground $param(fcolor) -text ""
        if {$found == 0} {
            # no next search results
            if {$first != {}} {
                # jump to the first
                set history_spos $first
            } else {
                # no search result
                .statusBar.lab configure -foreground $param(errcolor) \
                    -text "[set s($lang)(notfound)]"
            }
        }
        set history_pos($num) $history_spos
    }
    if {$isdict == 1} {
        # mark word in dict results - synonyms, antonyms etc.
        set cur 1.0
        set pattern {\{[^\}]*\}}
        while 1 {
            set cur [.result.text search -nocase -count length -regexp -- $pattern $cur end]
            if {$cur == ""} {
                break
            }
            set length [expr $length - 2]
            .result.text delete $cur
            .result.text delete "$cur + $length char"
            .result.text tag add matchfg $cur "$cur + $length char"
            set cur [.result.text index "$cur + $length char"]
        }
    } else {
        debug 4 "   find aux"
        set cur 1.0
        while 1 {
            set cur [.result.text search -nocase -count length -regexp -- {(\[[^]]*\]|\{[^\}]*\})} $cur end]
            if {$cur == ""} {
                break
            }
            .result.text tag add aux $cur "$cur + $length char"
            set cur [.result.text index "$cur + $length char"]
        }
    }
    if {$history_pos($num)} {
        #scroll
        debug 4 "Move to position $history_pos($num)"
        .result.text yview $history_pos($num)
    }
    .result.text configure -state disabled
    focus .search.s.entry

    # raise is slowly with KDE/Gnome :-/
    if {$param(raise) == 1} {
        debug 2 "raise top win"
        raise .
    }
    # automatically minimize?
    if {$param(do_automin) == 1 && $param(win_prop) == 2 && $param(autominDelay) > 0} {
        debug 2 "  automatically minimize after  $param(autominDelay) ms (display)"
        after $param(autominDelay) {hideResult 0}
    }    
    set param(autosearch_active) 0
    set param(autosearch_onchage_active) 0
    debug 1 "display return"
}


#### main

# if query is set via command line - search it:
if {[string length $query] > 0} {
    dictsearch $query
}


proc save {what} {
    global inshistory history_result param gparam s

    debug 2 "save $what"
    set lang $gparam(lang)
    if { $inshistory <= 0 || [string length $history_result($inshistory)] <= 0} {
	tk_messageBox -icon info -type ok -parent . -message \
        	[set s($lang)(nosave)]
	return
    }
    set f [tk_getSaveFile]
    if {$f == ""} {
        return
    }
    set err [catch "set fd \[open $f w\]"]
    if $err {
	tk_messageBox -icon error -type ok -parent . -message \
        	"Couldn't open $f for writing!"
        return
    }
    if {$what == 0} {		# current result
        puts $fd $history_result($inshistory)
    } else {                # all results in history
        for {set h [expr $inshistory + 1]} {$h <= [array size history_result]} {incr h} {
            puts $fd "$history_result($h)"
        }
        for {set h 1} {$h <= $inshistory} {incr h} {
            puts $fd "$history_result($h)"
        }
    }
    catch {close $fd}
}

proc interface_reset {toggle_result} {
    global defaultcursor

    debug 2 "interface_reset"
    after cancel animlogo .search.l.logo
    .search.l.logo configure -image "logo1"
    . configure -cursor $defaultcursor
    .result.text configure -cursor $defaultcursor
    .search.s.entry configure -cursor $defaultcursor

    if {$toggle_result == 1} {
        hideResult -1
    }
}

proc clipboard_copy_all {} {
    global last_selection param

    debug 2 "clipboard_copy_all"
    .result.text tag remove sel 1.0 end
    .result.text tag add sel 1.0 end
    if {$param(isunix)} {
        catch {set last_selection [selection get]}
    } else {
        catch {set last_selection [selection get -selection CLIPBOARD]}
    }
    catch {clipboard clear}
    catch {clipboard append $last_selection}
}

# places a window on the desktop
proc placeWin {win diff} {
    debug 8 "placeWin $win $diff"

    scan [wm geometry .] "%dx%d+%d+%d" w h x y
    set x [expr $x + $diff]
    set y [expr $y + $diff]
    debug 8 "   -> +$x+$y"
    wm geometry $win +$x+$y
}

proc aboutBox {} {
    global param gparam pinfo s defaultcursor

    debug 2 "aboutBox"
    set lang $gparam(lang)
    # just in case ...
    interface_reset 0

    if ![winfo exists .about] {
        toplevel .about
        wm group .about .
        wm title .about "$pinfo(pname) - [set s($lang)(about)]"
        wm resizable .about 0 0
        placeWin .about 50

        text .about.text -font lfont -wrap word -width 60 -height 26 \
            -relief groove -padx 8 -pady 8
        button .about.ok -text "Ok" -width 8 -command {
            after cancel animlogo .about.text.logo
            destroy .about
        }
        pack .about.text -side top -expand 1 -fill x -fill y -ipady 10 -ipadx 10
        pack .about.ok -side bottom -pady 8
        label .about.text.logo -image logo1 -bd 1
        animlogo .about.text.logo
        after 1500 {
            catch {after cancel animlogo .about.text.logo}
            catch {.about.text.logo configure -image "logo1"}
        }

        .about.text tag configure center -justify center
        .about.text tag configure bfont -font bfont -justify center
        .about.text tag configure homepage -foreground $param(highcolor) -underline 1 \
                -font bfont
        .about.text tag bind homepage <ButtonRelease-1> { urlOpen $pinfo(homepage)  }
        .about.text tag bind homepage <Enter> { .about.text config -cursor hand2}
        .about.text tag bind homepage <Leave> { .about.text config -cursor xterm}

        .about.text insert end " " center
        # .about.text image create end -image logo1 -pady 10 -align center
        .about.text window create end -window .about.text.logo -pady 10 -align center
        .about.text insert end " \n$pinfo(pname)\nVersion $pinfo(version)\n\n" bfont
        .about.text insert end "$pinfo(copyright)\n\nOnline: " center
        .about.text insert end "$pinfo(homepage)" homepage

        if {$gparam(lang) == "de"} {
        .about.text insert end "\nKommentare sind sehr willkommen!\n" center

        .about.text insert end "
Dieses Programm ist freie Software. Sie können es unter \
den Bedingungen der GNU General Public License, wie von der \
Free Software Foundation veröffentlicht, weitergeben und/oder \
modifizieren, entweder gemäß Version 2 der Lizenz oder (nach \
Ihrer Option) jeder späteren Version.

Die Veröffentlichung dieses Programms erfolgt in der \
Hoffnung, dass es Ihnen von Nutzen sein wird, aber OHNE \
IRGENDEINE GARANTIE, sogar ohne die implizite Garantie \
der MARKTREIFE oder der VERWENDBARKEIT FÜR EINEN BESTIMMTEN ZWECK. \
Details finden Sie in der GNU General Public License.

Sie sollten ein Exemplar der GNU General Public License zusammen \
mit diesem Programm erhalten haben. Falls nicht, siehe \
<http://www.gnu.org/licenses/>.
"

        } else {
            .about.text insert end "\nComments are welcome!\n" center
            .about.text insert end "
This program is free software; you can redistribute it and/or modify it \
under the terms of the GNU General Public License as published by the \
Free Software Foundation; either version 2 of the License, or (at your \
option) any later version.

This program is distributed in the hope that it will be useful, \
but WITHOUT ANY WARRANTY; without even the implied warranty of \
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \
GNU General Public License for more details.

You should have received a copy of the GNU General Public License \
along with this program. If not, see <http://www.gnu.org/licenses/>. 
"
        }
        .about.text configure -state disabled
    } else {
        wm deiconify .about
        raise .about 
    }
}

proc openHelpWindow {} {
    global param gparam s pinfo

    debug 2 "openHelpWindow"
    set lang $gparam(lang)
    if ![winfo exists .help] {
        toplevel .help
        wm group .help .
        wm title .help "$pinfo(pname) - [set s($lang)(help)]"
        # wm resizable .help 0 0
        placeWin .help 50

        text .help.text -font lfont -wrap word -width 80 -height 24 \
            -relief groove -yscrollcommand ".help.yscroll set" \
            -xscrollcommand ".help.xscroll set" \
            -padx 4 -pady 4 -wrap none
        scrollbar .help.yscroll -orient vertical \
            -command { .help.text yview }         
        scrollbar .help.xscroll -orient horizontal \
            -command { .help.text xview }         
        if {$param(isunix)} {          # I like smaller scrollbars
            .help.yscroll configure -width 10 -bd 1
            .help.xscroll configure -width 10 -bd 1
        }
        button .help.ok -text "Ok" -width 8 -command {destroy .help}
        pack .help.ok -side bottom -pady 8 
        pack .help.yscroll -side right -fill y
        pack .help.xscroll -side bottom -fill x
        pack .help.text -expand 1 -fill both

        .help.text tag configure center -justify center
        .help.text tag configure big -font bfont -justify center
        .help.text tag configure bfont -font bfont
        .help.text tag configure maillink -foreground $param(highcolor) -underline 1
        .help.text tag bind maillink <ButtonRelease-1> { sendMail }
        .help.text tag bind maillink <Enter> { .help.text config -cursor hand2}
        .help.text tag bind maillink <Leave> { .help.text config -cursor xterm}

        .help.text tag configure keylink -foreground $param(highcolor) -underline 1
        .help.text tag bind keylink <ButtonRelease-1> { helpKeys }
        .help.text tag bind keylink <Enter> { .help.text config -cursor hand2}
        .help.text tag bind keylink <Leave> { .help.text config -cursor xterm}

        .help.text tag configure flaglink -foreground $param(highcolor) -underline 1
        .help.text tag bind flaglink <ButtonRelease-1> { helpCmdline }
        .help.text tag bind flaglink <Enter> { .help.text config -cursor hand2}
        .help.text tag bind flaglink <Leave> { .help.text config -cursor xterm}

        .help.text tag configure abblink -foreground $param(highcolor) -underline 1
        .help.text tag bind abblink <ButtonRelease-1> { helpAbb }
        .help.text tag bind abblink <Enter> { .help.text config -cursor hand2}
        .help.text tag bind abblink <Leave> { .help.text config -cursor xterm}

        .help.text tag configure helplink -foreground $param(highcolor) -underline 1 -font bfont
        .help.text tag bind helplink <ButtonRelease-1> { helpGeneral }
        .help.text tag bind helplink <Enter> { .help.text config -cursor hand2}
        .help.text tag bind helplink <Leave> { .help.text config -cursor xterm}

        set w [expr round([winfo reqwidth .help.text] / 2) - 30]
        .help.text configure -tabs $w
         # mouse over text - highlight the line below the mouse pointer
         .help.text tag configure hilite -background $param(hicolor)
         bind .help.text <Motion> {
            global param
            if {$param(hilite)} {
                .help.text tag remove hilite 1.0 end
                if {[string compare [.help.text index "@%x, %y linestart"] "1.0"]} {
                    .help.text tag add hilite "@%x, %y linestart" "@%x, %y lineend"
                }
            }
        }
    } else {
        wm deiconify .help
        # raise .help 
        .help.text configure -state normal
        .help.text delete 0.0 end
    }
}

proc helpGeneral {} {
    global s gparam pinfo

    debug 2 "helpGeneral"
    set lang $gparam(lang)
    openHelpWindow

    .help.text insert end "\n$pinfo(pname) - [set s($lang)(help)]\nVersion $pinfo(version)\n\n" big

    if {$lang == "de"} {
        .help.text insert end {Suche starten:} bfont
        .help.text insert end {
   * Suchwort eingeben, Suchmethode auswählen, ENTER oder auf "Suche" drücken, oder
   * Doppelklick mit linker Maustaste auf Wort in Ergebnisfenster, oder
   * in anderem Fenser selektiertes Wort mit mittlerer Maustaste über 
     Ergebnisfenster "fallenlassen"
   * Suche im Ergebnis: 
       - Schrägstrich vor Suchwort: "/Suchwort" + ENTER oder
       - Suchwort eingeben, Umschalt+ENTER oder
       - mit mittlerer Maustaste auf "Suche" drücken oder
       - Umschalt-Taste drücken und selektiertes Wort mit mittlerer Maustaste
         über Ergebnisfenster "fallenlassen"
}
        .help.text insert end {
Suchworte angeben: } bfont
        .help.text insert end {
   * ein Suchwort oder
   * eins aus mehreren Wörtern (ODER-Verknüpfung): }
        .help.text insert end {Wort1,Wort2} bfont
        .help.text insert end {
   * alle Wörter (UND-Verknüpfung): }
        .help.text insert end {Wort1+Wort2} bfont
        .help.text insert end {
   * exakte Wortfolge: }
        .help.text insert end {Wort1 Wort2} bfont
        .help.text insert end {
   * }
        .help.text insert end {Umlaute: } bfont
        .help.text insert end {Falls Sie keine Umlaute auf der Tastatur haben, benutzen Sie:
        }
        .help.text insert end {"a = ä  "A = Ä  "o = ö  "O = Ö  "u = ü "U = Ü  "s = ß} bfont

        .help.text insert end {

Suchparameter: } bfont
        .help.text insert end {
   * Suche nach vollständigen Wörtern oder nach Muster in Wörtern?
   * Groß-/Kleinschreibweise ignorieren oder exakt beachten?
   * Korrekte Schreibweise oder, falls agrep benutzt wird, Fehlerkorrektur 
     versuchen?
   * Einfache Suche (* als Platzhalter für beliebige Zeichen) oder 
     reguläre Ausdrücke zulassen?
}

        .help.text insert end {
Andere Suchverhalten } bfont
        .help.text insert end { sind über das Menü (oder durch Klick auf "Suchwort") einstellbar: }
        .help.text insert end {
   Suche, sobald Maus über Fenster: } bfont
        .help.text insert end {
     * Selektieren Sie in einem anderen Fenster ein Wort (linke Maustaste)
     * Sobald Sie mit der Maus über das Ding-Fenster kommen, wird dieses 
       Wort mit aktueller Suchmethode gesucht.
        }
        .help.text insert end {
   Suche sofort bei neuer Textauswahl: } bfont
        .help.text insert end {
     * Sobald Sie in einem anderen Fenster ein Wort selektieren 
       (linke Maustaste), wird dieses Wort mit aktueller Suchmethode gesucht.
        } 

        .help.text insert end {
History-Funktion: } bfont
        .help.text insert end {
   * Frühere Suchergebnisse lassen sich wieder anzeigen (Knöpfe "<" bzw.  ">")
}
        .help.text insert end {
Zur Funktionsweise: } bfont
        .help.text insert end "
   * \"$pinfo(pname)\" ist kein intelligentes Dolmetscherprogramm, 
     sondern letztlich nur ein Front-End zur Suche in Dateien.
   * Die eigentliche Suche führt ein dafür existierendes Unix-Kommando aus der 
     \"grep\"-Famile durch. Hat man \"agrep\" installiert, kann man die Funktion 
     der \"fehlertoleranten Suche\" nutzen.
   * Die Ergebnisse sind nur so gut, wie die zugrundeliegende Wörterbuch-Datei.
     Zur Verbesserung dieser Datenbasis können Sie beitragen. 
     Senden Sie einfach "
        .help.text insert end {eine E-Mail an den Autor.} maillink

        .help.text insert end "\n\nWeitere Informationen:\n" bfont
        .help.text insert end "   * "
        .help.text insert end "Hilfe zu Tastaturkürzeln" keylink
        .help.text insert end "\n   * "
        .help.text insert end "Hilfe zu Startoptionen" flaglink
        .help.text insert end "\n   * "
        .help.text insert end "Hilfe zu Abkürzungen" abblink
        .help.text insert end "
   * Unix-Manuals zu agrep, egrep, ispell, dict\n\n"

    } else {                      # english
        .help.text insert end {Start search:} bfont
        .help.text insert end {
   * Type in search word, select a search method,
     then press ENTER or press the "Search" button, or
   * Double click on a word in the result window with left mouse button 1, or
   * Select a word in another X window, drop it by clicking with middle mouse
     button 2 over the result window.
   * Search in result: 
     - Type a slash, then the search word: "/word" + ENTER, or
     - Type in search word, then press Shift+ENTER, or
     - press the "Search" button with mouse middle button 2, or
     - press Shift and drop word by clicking with middle mouse button 2 
       over the result window.
}
        .help.text insert end {
Specify your search words: } bfont
        .help.text insert end {
   * Just one word, or
   * Find one of many words: }
        .help.text insert end {word1,word2} bfont
        .help.text insert end {
   * Find all words: }
        .help.text insert end {word1+word2} bfont
        .help.text insert end {
   * Find exact phrase: }
        .help.text insert end {word1 word2} bfont
        .help.text insert end {
   * }
        .help.text insert end {Umlauts: } bfont
        .help.text insert end {If you don't have umlaut keys on your keyboard, please use:
        }
        .help.text insert end {"a = ä  "A = Ä  "o = ö  "O = Ö  "u = ü  "U = Ü  "s = ß} bfont

        .help.text insert end {

Search options: } bfont
        .help.text insert end {
   * Search for full words or partial matches within words?
   * Ignore case or search case sensitive?
   * If agrep is used, try error correction if nothing is found?
   * Simple search (* is wildcard for any character) or search with
     regular expressions?
        }

        .help.text insert end {
Another search behavior } bfont
        .help.text insert end { can be selected via the menu, or by clicking on "search word": }
        .help.text insert end {
   Search on mouse over: } bfont
        .help.text insert end {
     * Select a word in another window (left mouse button)
     * As soon as you move the mouse over the Ding window
       this word will be searched with the current search method.
        }
        .help.text insert end {
   Search on new text selection: } bfont
        .help.text insert end {
     * As soon as you select a word in another window (left mouse button)
       this word will be searched with the current search method.
        } 

        .help.text insert end {
History function: } bfont
        .help.text insert end {
   * Previous search results could be displayed again ("<" and ">" buttons)
        }
        .help.text insert end {
How it works: } bfont
        .help.text insert end "
   * \"$pinfo(pname)\" is not an intelligent translator system, but \"only\"
     a front-end to search quickly in files.
   * The search itself is done by a dedicated Unix command  ala \"grep\".
     If you have installed \"agrep\" you are able to use the approximate
     matching feature to correct spelling errors.
   * Well, the results are as good as the dictionary wordlist. 
     You could contribute to improve this list!
     Simply send "
        .help.text insert end {an email to the author.} maillink

        .help.text insert end "\n\nFurther information:\n" bfont
        .help.text insert end "   * "
        .help.text insert end "Help on Keyboard shortcuts" keylink
        .help.text insert end "\n   * "
        .help.text insert end "Help on start options" flaglink
        .help.text insert end "\n   * "
        .help.text insert end "Help on abbreviations" abblink
        .help.text insert end "
   * Unix manual pages for agrep, egrep, ispell, dict \n\n"
    }
    .help.text configure -state disabled
}


proc helpKeys {} {
    global s gparam pinfo

    debug 2 "helpKeys"
    set lang $gparam(lang)
    openHelpWindow
    .help.text insert end "\n$pinfo(pname) - [set s($lang)(help)]\nVersion $pinfo(version)\n\n" big

    if {$lang == "de"} {
        .help.text insert end {Viele Funktionen lassen sich einfach und schnell über }
        .help.text insert end {Tastaturkürzel} bfont
        .help.text insert end " erreichen.\n\n"
        .help.text insert end {Im Suchwort ändern:} bfont
        .help.text insert end "
   Kursur links (rechts)\tÄndern im Suchwort
   Esc, Strg+u\tSuchwort löschen, evtl. Suche stoppen, Oberfläche rücksetzen
   Umschalt + Esc\tSuchwort löschen, evtl. Suche stoppen, Oberfläche rücksetzen
      \tFenster minimieren oder normale Größe
   Strg+a\tan den Anfang des Suchwortes
   Strg+e\tans Ende des Suchwortes
   Strg+Zurück, Strg+w\tLöscht ein Wort links von aktueller Position
   Strg+k\tLöschen von aktueller Position bis Ende\n\n"
        .help.text insert end {Suchmethode ändern:} bfont
        .help.text insert end "
   Strg + 1\tSuche mit Methode 1, 2 usw.
   Strg + 2 ...\t ... je nachdem, wieviele definiert\n\n"
        .help.text insert end {Im Ergebnis blättern:} bfont
        .help.text insert end "
   Kursur hoch (runter) / Rollmaus\t1 Zeile hoch (runter)
   Umschalt + Kursur hoch (runter) / Rollmaus\t5 Zeilen hoch (runter)
   Bild hoch (runter) / Alt + Rollmaus\t1 Seite hoch (runter)
   Pos 1\tan den Anfang
   Ende\tans Ende
   Umschalt + Kursur links (rechts)\tnach links (rechts) verschieben (bei langen Zeilen)

   Strg + Kursur hoch (runter)\tin früheren Suchergebnissen
   Strg + Rad der Rollmaus\tblättern (History)
\n"

        .help.text insert end {Menü-Funktionen:} bfont
        .help.text insert end "
   Strg + q\tProgramm beenden
   Strg + n\tNeues Programmfenster starten
   Strg + s\tAktuelles Ergebnis speichern
   Strg + l\tAlle Ergebnisse speichern
   Strg + c\tAktuelles Ergebnis in Zwischenablage
   Strg + m\tE-Mail an den Autor senden (nur Unix)\n\n"

        .help.text insert end {Sonstiges:} bfont
        .help.text insert end " 
   F1\tHilfe
   Strg + +\tSchrift vergrößern
   Strg + -\tSchrift verkleinern
   Strg + = oder Strg + 0\tStandard-Schriftgröße
   Strg + Klick links\tErgebnisse ein- oder ausklappen (wenn verfügbar)
   \n"
        .help.text insert end "Allgemeine Hilfe" helplink
        .help.text insert end "\n\n"

    } else {                      # english
        .help.text insert end {Many functions are easily available by }
        .help.text insert end {Keyboard shortcuts} bfont
        .help.text insert end ".\n\n"
        .help.text insert end {To change the search word:} bfont
        .help.text insert end "
   Cursor left (right)\tEdit in the current word
   Esc, Ctrl+u\tErase search word, Stop search, Reset interface
   Shift + Esc\tErase search word, Stop search, Reset interface
       \tminimize window or set normal size
   Ctrl+a\tGo to the begin of the search word
   Ctrl+e\tGo to end of the search word
   Ctrl+Backspace, Ctrl+w\tErase one word left from current position
   Ctrl+k\tErase from current position to the end\n\n"
        .help.text insert end {To change the search method:} bfont
        .help.text insert end "
   Ctrl + 1\tSearch with method 1, 2 etc..
   Ctrl + 2 ...\t ... if defined\n\n"
        .help.text insert end {Scroll in the results:} bfont
        .help.text insert end "
   Cursor up (down) / wheel mouse\t1 line up (down)
   Shift + Cursor up (down) / wheel mouse\t5 lines up (down)
   Page up (down) / Alt + wheel mouse\t1 page up (down)
   Pos 1\tto the beginning
   End\tto the end
   Shift + Cursor left (right)\tscroll left (right) (for long lines)

   Ctrl + Cursur up (down)\tbrowse through previous
   Ctrl + wheel of mouse\tsearch results (History)\n\n"

        .help.text insert end {Menu functions:} bfont
        .help.text insert end "
   Ctrl + q\tQuit program
   Ctrl + n\tStart new program window
   Ctrl + s\tSave current result
   Ctrl + l\tSave all results
   Strg + c\tCopy current result to clipboard
   Ctrl + m\tSend an e-mail to the author (Unix only)\n\n"
        .help.text insert end {Others:} bfont
        .help.text insert end " 
   F1\tHelp
   Ctrl + +\tIncrease font size
   Ctrl + -\tDecrease font size
   Ctrl + = or Ctrl + 0\tStandard font size
   Ctrl + click left\tFold or unfold search results (where available)
   \n"
        .help.text insert end {Umlauts: } bfont
        .help.text insert end {If you don't have umlaut keys on your keyboard, please use:
        }
        .help.text insert end {"a = ä  "A = Ä  "o = ö  "O = Ö  "u = ü  "U = Ü  "s = ß
        
        } bfont
        .help.text insert end "General help" helplink
        .help.text insert end "\n\n"

    }
    .help.text configure -state disabled
}

proc helpCmdline {} {
    global s gparam pinfo argv0 ding_usage

    debug 2 "helpCmdline"
    set lang $gparam(lang)
    openHelpWindow
    .help.text insert end "\n$pinfo(pname) - [set s($lang)(help)]\nVersion $pinfo(version)\n\n" big

    if {$lang == "de"} {
        .help.text insert end "Das Programm $argv0 kann mit verschiedenen Optionen (Flags) gestartet werden:\n"
        .help.text insert end "$ding_usage(de)"
        .help.text insert end "Allgemeine Hilfe" helplink
    } else {                      # english
        .help.text insert end "The program $argv0 may be started with different options (command line flags):\n"
        .help.text insert end "$ding_usage(en)"
        .help.text insert end "General help" helplink
    }
    .help.text insert end "\n\n"
    .help.text configure -state disabled
}

# updates the list of search methods in configuration
proc update_searchmeth {num} {
    global searchmeth searchmpos

    debug 2 "update_searchmeth $num"
    set sel [.ssearch.m.list curselection]
    set size [.ssearch.m.list size]
    .ssearch.m.list delete 0 $size
    foreach i $searchmpos {
        if {$searchmeth($i,name) != ""} {
            .ssearch.m.list insert end $searchmeth($i,name)
        }
    }
    if {$sel != ""} {
        set s [expr $sel + $num]
        if {($s <= $size && $s >= 0)} {
            .ssearch.m.list selection set $s
        }
    }
    # update
}

proc helpAbb {} {
    global s gparam pinfo

    debug 2 "helpAbb"
    set lang $gparam(lang)
    openHelpWindow
    set w [expr round([winfo reqwidth .help.text] / 7)]
    debug 4 "w = $w"
    .help.text tag configure abbtab -tabs "$w [expr 4 * $w] [expr 7 * $w]"
    .help.text tag configure abbtabb -tabs "$w [expr 4 * $w] [expr 7 * $w]" -font bfont
    .help.text insert end "\n$pinfo(pname) - [set s($lang)(help)]\nVersion $pinfo(version)\n\n" big

    if {$lang == "de"} {
        .help.text insert end {Abkürzungen im Deutsch <> Englischen Wörterbuch} bfont
    } else {                      # english
        .help.text insert end {Used abbreviations in the German <> English Dictionary} bfont
    }
    .help.text insert end "\n\n\tWortart\tPart of speech\n" abbtabb
    .help.text insert end "
{m}\tSubstantiv, männlich\tnoun, masculine
{f}\tSubstantiv, weiblich\tnoun, feminine
{n}\tSubstantiv, sächlich\tnoun, neuter
{pl}\tSubstantiv, Plural\tnoun, plural
{vt}\tVerb, transitiv\tverb, transitive
{vi}\tVerb, intransitiv\tverb, intransitive
{vr}\tVerb, reflexiv\tverb, reflexive
{adj}\tAdjektiv\tadjective
{adv}\tAdverb\tadverb
{prp}\tPräposition\tpreposition
{num}\tNumeral, Zahlwort\tnumeral
{art}\tArtikel\tarticle
{ppron}\tPersonalpronomen\tpersonal pronoun
{conj}\tKonjunktion\tconjunction
{interj}\tInterjektion; Ausruf \tinterjection

etw. - sth.\tetwas\tsomething
jds. - sb.'s\tjemandes (Genitiv)\tsomebody's
jdm. - sb.\tjemandem (Dativ)\tsomebody
jdn. - sb.\tjemanden (Akkusativ)\tsomebody
usw. - etc.\tund so weiter\tet cetera; and so on
" abbtab
    .help.text insert end "\n\tVerwendung\tUsage\n" abbtabb
    .help.text insert end "
\[alt\]\talte deutsche Rechtschreibung\told German spelling
\[obs.\]\tveraltet; nicht mehr gebräuchlich\tobsolete
\[Am.\]\tAmerikanisches Englisch\tAmerican English
\[Br.\]\tBritisches Englisch\tBritish English
\[Sc.\]\tSchottisches Englisch\tScottish English
\[Austr.\]\tAutralisches Englisch\tAustralian English
\[Süddt.\]\tSüddeutsch\tSouthern German
\[Ös.\]\tösterreichisches Deutsch\tAustrian German
\[Schw.\]\tSchweizerisch\tSwiss German
\[ugs.\] \[coll.\]\tumgangssprachlich\tcolloquial
\[übtr.\] \[fig.\]\tübertragen; bildlich\tfigurative
\[slang\]\tJargon, Slang; saloppe Umgangssprache\tslang
\[Sprw.\] \[prov.\]\tSprichwort\tproverb
\[tm\]\tHandelsmarke; Warenzeichen\ttrademark
" abbtab

    .help.text insert end "\n\tFachgebiete\tSpecial branches\n" abbtabb
    .help.text insert end "
\[anat.\]\tAnatomie\tanatomy
\[arch.\]\tArchitektur\tarchitecture
\[astron.\]\tAstronomie\tastronomy
\[auto\]\tAutos; Automobilindustrie\tcars; automotive industry
\[biochem.\]\tBiochemie\tbiochemistry
\[biol.\]\tBiologie\tbiology
\[bot.\]\tBotanik; Pflanzen\tbotany; plants
\[chem.\]\tChemie\tchemistry
\[comp.\]\tComputer\tcomputer
\[constr.\]\tBauwesen\tconstruction
\[econ.\]\tÖkonomie; Wirtschaft\teconomy
\[electr.\]\tElektrotechnik, Elektronik\telectrical engineering, electronics
\[cook.\]\tSpeisen; Kochen; Essen; Gastronomie\tdishes; cooking; eating; gastronomy
\[geogr.\]\tGeografie\tgeography
\[geol.\]\tGeologie\tgeology
\[gramm.\]\tGrammatik\tgrammar
\[jur.\]\tRecht, Jura\tlaw
\[math.\]\tMathematik\tmathematics
\[med.\]\tMedizin\tmedicine
\[mil.\]\tMilitär\tmilitary
\[min.\]\tMineralogie\tmineralogy
\[mus.\]\tMusik\tmusic
\[naut.\]\tNautik; Schifffahrtskunde\tnautical science; seafaring
\[ornith.\]\tOrnithologie; Vogelkunde\tornithology
\[pharm.\]\tPharmakologie; Arzneimittelkunde\tpharmacology
\[phil.\]\tPhilosophie\tphilosophy
\[phys.\]\tPhysik\tphysics
\[pol.\]\tPolitik\tpolitics
\[relig.\]\tReligion\treligion
\[sport\]\tSport\tsports
\[techn.\]\tTechnik\ttechnology; engineering
\[textil.\]\tTextilindustrie\ttextile industry
\[zool.\]\tZoologie; Tiere\tzoology; animals
" abbtab

    if {$lang == "de"} {
        .help.text insert end "\n\nAllgemeine Hilfe" helplink
    } else {
        .help.text insert end "\n\nGeneral help" helplink
    }
    .help.text insert end "\n\n"
    .help.text configure -state disabled
}

proc setSearch {} {
    global s pinfo default_searchmeth searchmeth searchmpos gparam param grepcmds

    debug 2 "setSearch"
    set lang $gparam(lang)
    if ![winfo exists .ssearch] {
        toplevel .ssearch
        wm group .ssearch .
        wm title .ssearch "$pinfo(pname): [set s($lang)(searchm)]"
        wm iconname .ssearch "dict"
        placeWin .ssearch 50

        frame .ssearch.buttons
        pack .ssearch.buttons -side bottom -fill x
        button .ssearch.buttons.ok -text [set s($lang)(apply)] -command {
            update_searchmeth_menu
            if {$param(autosave) != 0} {
                saveOptions
            }
            destroy .ssearch
        }
        button .ssearch.buttons.cancel -text [set s($lang)(cancel)] -command "destroy .ssearch"
        pack .ssearch.buttons.ok .ssearch.buttons.cancel \
            -side left -expand 1 -pady 8 -padx 8

        # Methods
        frame .ssearch.m -bd 2 -relief groove
        pack .ssearch.m -side top -fill x -ipady 10
        scrollbar .ssearch.m.scroll -command ".ssearch.m.list yview"
        if {$param(isunix)} {          # I like smaller scrollbars
            .ssearch.m.scroll configure -width 10 -bd 1
        }
        listbox .ssearch.m.list -yscroll ".ssearch.m.scroll set" \
            -setgrid 1 -height 4
        menubutton .ssearch.m.new -text [set s($lang)(new)] -width 8 \
            -menu .ssearch.m.new.menu -indicatoron 1 -relief raised \
            -anchor c -direction flush
        
        menu .ssearch.m.new.menu -font lfont -tearoff 0
        for {set j 0} {[info exists default_searchmeth($j,name)]} {incr j} {
            # check for available search cmds
            set state "disabled"
            foreach c $default_searchmeth($j,grepcmds) {
                if [info exists grepcmds($c)] {
                    set state "active"
                    break
                }
            }
            .ssearch.m.new.menu add command -label "$default_searchmeth($j,name)" \
                -state $state -command "setSearchOptions {} $j"
        }
        .ssearch.m.new.menu add command -label "Generic" -command "setSearchOptions {} -1"

        button .ssearch.m.edit -text [set s($lang)(edit)] -width 8 \
            -state disabled -command {
            if {[.ssearch.m.list curselection] != {}} {
                setSearchOptions [lindex $searchmpos [.ssearch.m.list curselection]] {}
            }
        }
        button .ssearch.m.delete -text [set s($lang)(delete)] -width 8 \
            -state disabled -command {
            if {[.ssearch.m.list curselection] != {}} {
                set sel [.ssearch.m.list curselection]
                set searchmeth([lindex $searchmpos $sel],name) ""
                set searchmpos [lreplace $searchmpos $sel $sel]
                update_searchmeth 0
            }
        }

        button .ssearch.m.up -image up -state disabled -command {
            if {[.ssearch.m.list curselection] != {}} {
                set sel [.ssearch.m.list curselection]
                if {$sel > 0} {
                    set pos [lindex $searchmpos $sel]
                    set searchmpos [lreplace $searchmpos $sel $sel]
                    set searchmpos [linsert $searchmpos [expr $sel - 1] $pos]
                    update_searchmeth -1
                }
            }
        }
        button .ssearch.m.down -image down -state disabled -command {
            if {[.ssearch.m.list curselection] != {}} {
                set sel [.ssearch.m.list curselection]
                if {$sel < [expr [.ssearch.m.list size] - 1]} {
                    set pos [lindex $searchmpos $sel]
                    set searchmpos [lreplace $searchmpos $sel $sel]
                    set searchmpos [linsert $searchmpos [expr $sel + 1] $pos]
                    update_searchmeth 1
                }
            }
        }
        grid .ssearch.m.list -in .ssearch.m -row 0 -column 0 -rowspan 5 \
            -sticky w,n,s -pady 4
        grid .ssearch.m.scroll -in .ssearch.m -row 0 -column 1 -rowspan 5 \
            -sticky w,n,s -pady 4
        grid .ssearch.m.up -in .ssearch.m -row 1 -column 2 -rowspan 1 \
             -padx 4 -sticky n
        grid .ssearch.m.down -in .ssearch.m -row 1 -column 2 -rowspan 1 \
             -padx 4 -sticky s
        grid .ssearch.m.new -in .ssearch.m -row 0 -column 3 -rowspan 1 \
             -padx 8 -pady 4
        grid .ssearch.m.edit -in .ssearch.m -row 1 -column 3 -rowspan 1 \
             -padx 8 -pady 4
        grid .ssearch.m.delete -in .ssearch.m -row 2 -column 3 -rowspan 1 \
             -padx 8 -pady 4

        # grid .ssearch.m.down -in .ssearch.m -row 1 -column 2 -rowspan 1 \
        #      -padx 8 -pady 4

        bind .ssearch.m.list <Double-1> {
            setSearchOptions [lindex $searchmpos [.ssearch.m.list curselection]] {}
        }
        bind .ssearch.m.list <Return> {
            setSearchOptions [lindex $searchmpos [.ssearch.m.list curselection]] {}
        }
        bind .ssearch.m.list <1> {
            .ssearch.m.up configure -state normal
            .ssearch.m.down configure -state normal
            .ssearch.m.edit configure -state normal
            .ssearch.m.delete configure -state normal
        }
        update_searchmeth 0

    } else {
        wm deiconify .ssearch
        raise .ssearch
    }
}

proc setSearchOptions {num type} {
    global searchmeth default_searchmeth default_searchopts searchmpos grepcmds
    global param gparam pinfo s

    debug 1 "setSearchOptions $num $type"
    set lang $gparam(lang)
    variable smeth
    if [array exists smeth] {
        unset smeth
    }
    variable new 0
    variable n $num
    if {$num != ""} {
        foreach i [array names searchmeth "$num,*"] {
            regsub "$num," $i "" j
            set smeth($j) $searchmeth($i)
        }
    } else {
        set n 0
        set new 1
        array set smeth [array get default_searchopts]
        foreach i [array names default_searchmeth "$type,*"] {
            regsub "$type," $i "" j
            set smeth($j) $default_searchmeth($i)
        }
        # set smeth(grepopts) $grepcmds($smeth(grepcmd))
        # set smeth(name) ""
        foreach i [array names searchmeth "*,name"] {
            incr n
        }
        set smeth(type) $type
    }
    if [winfo exists .sopts] {
        wm deiconify .sopts
        raise .sopts
    } else {
        toplevel .sopts
        wm group .sopts .
        wm title .sopts "$pinfo(pname): [set s($lang)(searcho)]"
        wm iconname .sopts "dict"
        placeWin .sopts 70

        frame .sopts.buttons
        pack .sopts.buttons -side bottom -fill x
        button .sopts.buttons.ok -text [set s($lang)(apply)] -command {
            if {$smeth(name) == ""} {
                tk_messageBox -icon info -type ok -parent .sopts \
                    -message [set s($lang)(namerequired)]
                focus .sopts.c.n
                return
            }
            set searchmeth($n,name)      $smeth(name)
            set searchmeth($n,type)      $smeth(type)
            set searchmeth($n,grepcmd)   $smeth(grepcmd)
            set searchmeth($n,grepopts)  $smeth(grepopts)
            set searchmeth($n,dictfile)  $smeth(dictfile)
            set df [glob -nocomplain $smeth(dictfile)]
            set searchmeth($n,dictfiles) $df
            set searchmeth($n,separator) $smeth(separator)
            set searchmeth($n,language1) $smeth(language1)
            set searchmeth($n,language2) $smeth(language2)
            set searchmeth($n,minlength) $smeth(minlength)
            set searchmeth($n,maxlength) $smeth(maxlength)
            set searchmeth($n,maxresults) $smeth(maxresults)
            set searchmeth($n,shapedresult) $smeth(shapedresult)
            set searchmeth($n,foldedresult) $smeth(foldedresult)
            set searchmeth($n,avail) 1
            if {$new == 1} {           # new
                lappend searchmpos $n
            }
            update_searchmeth 0
            unset smeth
            destroy .sopts
        }
        button .sopts.buttons.st -text [set s($lang)(default)] -command {
            if {$new == 1} {           # new
                array set smeth [array get default_searchopts]
            } else {
                foreach i [array names searchmeth "$n,*"] {
                    regsub "$n," $i "" j
                    set smeth($j) $searchmeth($i)
                }
            }
        }
        button .sopts.buttons.cancel -text [set s($lang)(cancel)] \
            -command {
                unset smeth
                destroy .sopts
            }
        pack .sopts.buttons.ok .sopts.buttons.st .sopts.buttons.cancel \
            -side left -expand 1 -pady 8

        # Command
        frame .sopts.c -bd 2 -relief groove
        pack .sopts.c -side top -fill x -ipady 10
        label .sopts.c.ln -text "[set s($lang)(name)]:" -font bfont
        entry .sopts.c.n -textvariable smeth(name) -font bfont -width 15
        label .sopts.c.l -text "[set s($lang)(grepcmd)]:" -font lfont


        if {$type != -1} {
            # pre-definded cmd
            menubutton .sopts.c.m -textvariable smeth(grepcmd) -menu .sopts.c.m.m \
                -indicatoron 1 -relief raised -anchor c -direction flush \
                -font lfont -width 13
            menu .sopts.c.m.m -font lfont -tearoff 0
            foreach c $default_searchmeth($smeth(type),grepcmds) {
                # all defined commands for this method
                if {![info exists grepcmds($c)]} {
                     # not available in current system
                     continue
                }
                if {$smeth(grepcmd) == ""} {    # no default command yet
                    set smeth(grepcmd) $c
                    if ![info exists smeth(grepopts)] {
                        # don't override specific options
                        set smeth(grepopts) "$grepcmds($c)"
                    }
                }
                if {$new == 1 || [string compare $c $searchmeth($n,grepcmd)] != 0} {
                    # no options set so far
                    if {[info exists default_searchmeth($smeth(type),grepopts)]} {
                            # special options for this method
                        set cmd "set smeth(grepopts) \"$default_searchmeth($smeth(type),grepopts)\""
                    } else {
                        # default options for this command
                        set cmd "set smeth(grepopts) \"$grepcmds($c)\""
                    }
                } else {
                        # set default options
                    set cmd "set smeth(grepopts) \"$searchmeth($n,grepopts)\""
                }
                set cmd "$cmd; set smeth(grepcmd) $c"

                .sopts.c.m.m add command -label $c -font lfont -command $cmd
            }
        } else {
            # generic command - TODO!
            entry .sopts.c.m
        }
        label .sopts.c.l2 -text "[set s($lang)(grepopts)]:" -font lfont
        entry .sopts.c.o -textvariable smeth(grepopts) -font lfont -width 13
        grid .sopts.c.ln -in .sopts.c -row 0 -column 0 -rowspan 1 -sticky e \
            -padx 4 -pady 4
        grid .sopts.c.n -in .sopts.c -row 0 -column 1 -rowspan 1 -sticky w \
            -padx 4 -pady 4
        grid .sopts.c.l -in .sopts.c -row 1 -column 0 -rowspan 1 -sticky e \
            -padx 4 -pady 4
        grid .sopts.c.m -in .sopts.c -row 1 -column 1 -rowspan 1 -sticky w \
            -padx 4 -pady 4
        grid .sopts.c.l2 -in .sopts.c -row 2 -column 0 -rowspan 1 -sticky e \
            -padx 4 -pady 4
        grid .sopts.c.o -in .sopts.c -row 2 -column 1 -rowspan 1 -sticky w \
            -padx 4 -pady 4

        # File
        frame .sopts.file -bd 2 -relief groove 
        pack .sopts.file -side top -fill x -ipadx 10 -ipady 10 -pady 10

        label .sopts.file.l -text "[set s($lang)(dictfile)]: " \
            -font lfont
        entry .sopts.file.e -width 36 -font lfont \
            -textvariable smeth(dictfile)
        variable types {
            {"Text files" {.txt .vok .dic}}
            {"All files" *}
        }

        button .sopts.file.b -font lfont -text "Browse ..." \
            -command {
                set f [tk_getOpenFile -initialdir [file dirname $smeth(dictfile)] \
                    -filetypes $types -parent .sopts]
                if [string compare $f ""] {
                    set smeth(dictfile) $f
                }
            }
        grid .sopts.file.l -in .sopts.file -row 0 -column 0 -columnspan 6
        grid .sopts.file.e -in .sopts.file -row 1 -column 0 -columnspan 5 -sticky e
        grid .sopts.file.b -in .sopts.file -row 1 -column 6 

        label .sopts.file.l1 -text "[set s($lang)(lang)] 1:" -font lfont
        label .sopts.file.lt -text "[set s($lang)(sep)]:" -font lfont
        label .sopts.file.l2 -text "[set s($lang)(lang)] 2:" -font lfont
        entry .sopts.file.e1 -font lfont -textvariable smeth(language1) -width 10
        entry .sopts.file.et -font lfont -textvariable smeth(separator) -width 5
        entry .sopts.file.e2 -font lfont -textvariable smeth(language2) -width 10


        grid .sopts.file.l1 -in .sopts.file -row 2 -column 0 -padx 4 -columnspan 2
        grid .sopts.file.lt -in .sopts.file -row 2 -column 2 -padx 4 -columnspan 2
        grid .sopts.file.l2 -in .sopts.file -row 2 -column 4 -padx 4 -columnspan 2
        grid .sopts.file.e1 -in .sopts.file -row 3 -column 0 -padx 4 -columnspan 2
        grid .sopts.file.et -in .sopts.file -row 3 -column 2 -padx 4 -columnspan 2
        grid .sopts.file.e2 -in .sopts.file -row 3 -column 4 -padx 4 -columnspan 2
        

        frame .sopts.search -bd 2 -relief groove
        pack .sopts.search -side top -fill x -ipadx 10 -ipady 10
        label .sopts.search.rl -text "[set s($lang)(maxresults)]:" -font lfont
        entry .sopts.search.re -justify right -width 5 -font lfont -textvariable smeth(maxresults)
        label .sopts.search.ll -text "[set s($lang)(minlength)]:" -font lfont
        entry .sopts.search.le -justify right -width 5 -font lfont -textvariable smeth(minlength)
        label .sopts.search.ml -text "[set s($lang)(maxlength)]:" -font lfont
        entry .sopts.search.me -justify right -width 5 -font lfont -textvariable smeth(maxlength)
        checkbutton .sopts.search.shaped -text [set s($lang)(shaped)] -font lfont \
            -variable smeth(shapedresult)
        checkbutton .sopts.search.folded -text [set s($lang)(folded)] -font lfont \
            -variable smeth(foldedresult)

        grid .sopts.search.rl -in .sopts.search -row 0 -column 0 -rowspan 1 -sticky e -padx 0
        grid .sopts.search.re -in .sopts.search -row 0 -column 1 -rowspan 1 -sticky w -padx 0
        grid .sopts.search.ll -in .sopts.search -row 1 -column 0 -rowspan 1 -sticky e -padx 0
        grid .sopts.search.le -in .sopts.search -row 1 -column 1 -rowspan 1 -sticky w -padx 0
        grid .sopts.search.ml -in .sopts.search -row 2 -column 0 -rowspan 1 -sticky e -padx 0
        grid .sopts.search.me -in .sopts.search -row 2 -column 1 -rowspan 1 -sticky w -padx 0
        grid .sopts.search.shaped -in .sopts.search -row 3 -column 0 -rowspan 1 -sticky w -padx 0
        grid .sopts.search.folded -in .sopts.search -row 4 -column 0 -rowspan 1 -sticky w -padx 0
    }

    if {! [info exists default_searchmeth($smeth(type),dictfile)]} {
        .sopts.file.e configure -state disabled
        .sopts.file.b configure -state disabled
        .sopts.file.l configure -foreground darkgray
    }    
    if {! [info exists default_searchmeth($smeth(type),separator)]} {
        .sopts.file.et configure -state disabled
        .sopts.file.lt configure -foreground darkgray
    }    
    if {! [info exists default_searchmeth($smeth(type),language2)]} {
        .sopts.file.e2 configure -state disabled
        .sopts.file.l2 configure -foreground darkgray
    }    
}

proc setGeneral {} {
    global default
    global pinfo s languages
    global param gparam

    debug 1 "setGeneral"
    set lang $gparam(lang)
    if ![winfo exists .general] {
        toplevel .general
        wm group .general .
        wm title .general "$pinfo(pname): [set s($lang)(general)]"
        wm iconname .general "ding"
        placeWin .general 50

        variable fc "$param(fcolor)"
        variable bc "$param(bcolor)"
        variable ll $lang
        variable changes_restart 0
        variable ffamily
        variable fsize
        variable fstyle
        variable lffamily
        variable lfsize
        variable lfstyle
        set ffamily [lindex $param(tfont) 0]
        set fsize [lindex $param(tfont) 1]
        set fstyle [lindex $param(tfont) 2]
        set lffamily [lindex $param(lfont) 0]
        set lfsize [lindex $param(lfont) 1]
        set lfstyle [lindex $param(lfont) 2]

        variable omaxhistory $param(maxhistory)

        frame .general.buttons
        pack .general.buttons -side bottom -fill x

        button .general.buttons.ok -text [set s($lang)(apply)] -command {
            if {$gparam(lang) != $ll} {
                set gparam(lang) $ll
                set lang $ll
                set changes_restart 1
            }
            set tf [list $ffamily $fsize $fstyle]
            if [string compare "$tf" "$param(tfont)"] {
                set param(tfont) $tf
                chFont tfont
                set param(ifont)  [list $ffamily $fsize normal italic]
                chFont ifont
                # .result.text configure -font $param(tfont)
                # .search.s.entry configure -font $param(tfont)
            }
            set lf [list $lffamily $lfsize $lfstyle]
            if [string compare "$lf" "$param(lfont)"] {
                set param(lfont) $lf
                set param(bfont)  [list $lffamily $lfsize bold]
                set param(sfont) [list $lffamily [expr $lfsize - 2] $lfstyle]
                chFont lfont
                chFont bfont
                chFont sfont
            }
            if {[string compare $param(fcolor) $fc] || [string compare $param(bcolor) $bc]} {
                # color change
                set param(fcolor) "$fc"
                set param(bcolor) "$bc"
                tk_setPalette foreground "$fc" background "$bc" 

                left configure -foreground $param(fcolor)
                right configure -foreground $param(fcolor)
                up configure -foreground $param(fcolor)
                down configure -foreground $param(fcolor)
                plus configure -foreground $param(bcolor)
                plus configure -background $param(fcolor)
                minus configure -foreground $param(bcolor)
                minus configure -background $param(fcolor)

                if {[winfo depth .] > 1} {      # Color display
                    # other background color for result text
                    set cols [shadeColor $param(fcolor) $param(bcolor)]
                    set param(shadedcolor) [lindex $cols 0]
                    set param(highcolor) [lindex $cols 1]
                    set param(errcolor) [lindex $cols 2]
                    set param(hicolor) [lindex $cols 3]
                    .result.text configure -selectbackground $param(fcolor) -selectforeground $param(bcolor)
                    .search.s.entry configure -selectbackground $param(fcolor) -selectforeground $param(bcolor)
                    .result.text tag configure bg1 -background $param(shadedcolor)
                    .result.text tag configure matchfg -foreground $param(highcolor)
                    .result.text tag configure search -background $param(highcolor) -foreground $param(bcolor)
                    .result.text tag configure u -background $param(fcolor) \
                        -foreground $param(bcolor)
                    .result.text tag configure hilite -background $param(hicolor)
                    setSearchBg $param(shadedcolor)
                }
                if {($curhistory <= 0) || ([string length $query] == 0 && ! $mini)} {
                    welcome 1
                }
            }
            if {$param(win_prop) == 2 && $param(autominDelay) > 0} {
                    set param(do_automin) 1
            }
            if {$changes_restart == 1} {
                tk_messageBox -icon info -type ok -parent .general -message \
                    [set s($lang)(changes_later)]
            }
            if {$param(autosave) != 0} {
                saveOptions
            }
            destroy .general
        }
        button .general.buttons.st -text [set s($lang)(default)] -command {
            set lang $default(language)
            set llabel $languages($lang)
            set fc $default(fcolor)
            set bc $default(bcolor)
            .general.c.fl configure -background $fc
            .general.c.bl configure -background $bc
            set ffamily [lindex $default(tfont) 0]
            set fsize [lindex $default(tfont) 1]
            set lffamily [lindex $default(lfont) 0]
            set lfsize [lindex $default(lfont) 1]
            set param(showBalloons) $default(showBalloons)
            set param(balloonDelay) $default(balloonDelay)
            set param(autosearch) $default(autosearch)
            set param(autosearchDelay) $default(autosearchDelay)
            set param(win_prop) $default(win_prop)
            set param(autominDelay) $default(autominDelay)
            set param(hilite) $default(hilite)
            set param(raise) $default(raise)
            set param(maxhistory)   $default(maxhistory)
            set param(autosave) $default(autosave)
        }
        button .general.buttons.cancel -text [set s($lang)(cancel)] \
            -command "destroy .general"
        pack .general.buttons.ok .general.buttons.st .general.buttons.cancel \
            -side left -expand 1 -pady 8 -padx 8

        # language
        frame .general.l -bd 2 -relief groove
        pack .general.l -side top -fill x -ipady 10
        label .general.l.l -text "[set s($lang)(lang)]:" -font lfont
        variable llabel
        set llabel $languages($lang)
        menubutton .general.l.m -textvariable llabel -menu .general.l.m.m \
            -indicatoron 1 -relief raised -anchor c -direction flush \
            -font lfont -width 13
        menu .general.l.m.m -font lfont -tearoff 0
        foreach i [array names languages] {
            .general.l.m.m add command -label $languages($i) -font lfont \
                -command "set ll $i; set llabel $languages($i)"
        }
        grid .general.l.l -in .general.l -row 0 -column 0 -rowspan 1 -sticky e \
            -padx 4 -pady 4
        grid .general.l.m -in .general.l -row 0 -column 1 -rowspan 1 -sticky w \
            -padx 4 -pady 4

        # colors
        frame .general.c -bd 2 -relief groove
        pack .general.c -side top -fill x -ipady 10 -pady 10

        button .general.c.fb -text [set s($lang)(fg)] -width 18 -font lfont \
            -command {
                set fc [selectColor .general $fc fg]
                raise .general
                if [string compare $fc ""] {
                    .general.c.fl configure -background $fc
                }
            }
        button .general.c.bb -text [set s($lang)(bg)] -width 18 -font lfont \
            -command {
                set bc [selectColor .general $bc bg]
                raise .general
                if [string compare $bc ""] {
                    .general.c.bl configure -background $bc
                }
            }
        label .general.c.fl -background $fc -width 13 -relief groove
        label .general.c.bl -background $bc -width 13 -relief groove
        button .general.c.flip -text [set s($lang)(change)] -font lfont \
            -command { set obc $bc; set bc $fc; set fc $obc; 
                .general.c.fl configure -background $fc
                .general.c.bl configure -background $bc
            }
        grid .general.c.fb -in .general.c -row 0 -column 0 -sticky e \
            -padx 4 -pady 4
        grid .general.c.fl -in .general.c -row 0 -column 1 -sticky ew \
            -padx 4 -pady 4
        grid .general.c.bb -in .general.c -row 1 -column 0 -sticky e \
            -padx 4 -pady 4
        grid .general.c.bl -in .general.c -row 1 -column 1 -sticky ew \
            -padx 4 -pady 4
        grid .general.c.flip -in .general.c -row 0 -column 2 -rowspan 2 -sticky e \
            -padx 4 -pady 4

        # Fonts
        # frame .general.f -bd 2 -relief groove
        pack .general.c -side top -fill x -ipady 10 -pady 10
        label .general.c.l -text "[set s($lang)(tfont)]: " -font lfont
        label .general.c.l2 -text "[set s($lang)(lfont)]: " -font lfont

        menubutton .general.c.f -textvariable ffamily -menu .general.c.f.m \
            -indicatoron 1 -relief raised -anchor c -direction flush \
            -font lfont -width 13
        menu .general.c.f.m -font lfont -tearoff 0
        menubutton .general.c.f2 -textvariable lffamily -menu .general.c.f2.m \
            -indicatoron 1 -relief raised -anchor c -direction flush \
            -font lfont -width 13
        menu .general.c.f2.m -font lfont -tearoff 0

        set allfams [lsort -unique [font families]]
        set found_fonts 0
        if {[llength $param(tfonts)] > 0} {
            foreach i $param(tfonts) {
                foreach f [lsearch -glob -all -inline $allfams $i] {
                # if {[lsearch $allfams [string tolower $i]] != -1}
                    .general.c.f.m add command -label $f -font lfont \
                        -command "set ffamily {$f}"
                    .general.c.f2.m add command -label $f -font lfont \
                        -command "set lffamily {$f}"
                    incr found_fonts
                    debug 8 "adding font $f"
                }
            }
        }
        if {$found_fonts < 3} {        # use all available fonts
            foreach i $allfams {
                .general.c.f.m add command -label $i -font lfont \
                    -command "set ffamily {$i}"
                .general.c.f2.m add command -label $i -font lfont \
                    -command "set lffamily {$i}"
            }
        }
        menubutton .general.c.s -textvariable fsize -menu .general.c.s.m \
            -indicatoron 1 -relief raised -anchor c -direction flush \
            -font lfont -width 4
        menu .general.c.s.m -font lfont -tearoff 0
        menubutton .general.c.s2 -textvariable lfsize -menu .general.c.s2.m \
            -indicatoron 1 -relief raised -anchor c -direction flush \
            -font lfont -width 4
        menu .general.c.s2.m -font lfont -tearoff 0
        foreach i {7 8 10 12 14 15 16 18 24} {
            .general.c.s.m add command -label "$i" -font lfont \
                -command "set fsize \"$i\""
            .general.c.s2.m add command -label "$i" -font lfont \
                -command "set lfsize \"$i\""
        }

        grid .general.c.l -in .general.c -row 2 -column 0 -sticky e \
            -padx 4 -pady 4
        grid .general.c.f -in .general.c -row 2 -column 1 -sticky w \
            -padx 4 -pady 4
        grid .general.c.s -in .general.c -row 2 -column 2 -sticky w \
            -padx 4 -pady 4
        grid .general.c.l2 -in .general.c -row 3 -column 0 -sticky e \
            -padx 4 -pady 4
        grid .general.c.f2 -in .general.c -row 3 -column 1 -sticky w \
            -padx 4 -pady 4
        grid .general.c.s2 -in .general.c -row 3 -column 2 -sticky w \
            -padx 4 -pady 4

        # History, Balloon help, search behavior, autosave
        frame .general.b -bd 2 -relief groove
        pack .general.b -side top -fill x -ipady 10
        label .general.b.hl -text "[set s($lang)(maxhistory)]:" -font lfont
        entry .general.b.he -justify right -width 5 -font lfont \
            -textvariable param(maxhistory)

        checkbutton .general.b.help -text [set s($lang)(balloon)] -font lfont \
            -variable param(showBalloons) -command {
                if {$param(showBalloons) == 1} {
                    .general.b.e configure -state normal
                    .general.b.l1 configure -state normal
                    .general.b.l2 configure -state normal
                } else {
                    .general.b.e configure -state disabled
                    .general.b.l1 configure -state disabled
                    .general.b.l2 configure -state disabled
                }
             }

        label .general.b.l1 -text [set s($lang)(after)] -font lfont
        entry .general.b.e -width 5 -textvariable param(balloonDelay) \
            -font lfont -justify right
        label .general.b.l2 -text [set s($lang)(ms)] -font lfont

        # Autosearch:
        checkbutton .general.b.autosearch -text [set s($lang)(autosearch)] -font lfont \
            -variable param(autosearch) -command {
                if {$param(autosearch) == 1} {
                    .general.b.autosearche configure -state normal
                    .general.b.autosearchl1 configure -state normal
                    .general.b.autosearchl2 configure -state normal
                } else {
                    .general.b.autosearche configure -state disabled
                    .general.b.autosearchl1 configure -state disabled
                    .general.b.autosearchl2 configure -state disabled
                }
             }
        set state [expr {$param(autosearch) == 1 ? {normal} : {disabled}}]
        label .general.b.autosearchl1 -text [set s($lang)(after)] -font lfont \
            -state $state
        entry .general.b.autosearche -width 5 -textvariable param(autosearchDelay) \
            -font lfont -justify right -state $state
        label .general.b.autosearchl2 -text [set s($lang)(ms)] -font lfont \
            -state $state

        # Autominimize:
        checkbutton .general.b.automin -text [set s($lang)(automin)] -font lfont \
            -variable param(win_prop) -onvalue 2 -offvalue 0 -command {
                if {$param(win_prop) == 2} {
                    .general.b.automine configure -state normal
                    .general.b.autominl1 configure -state normal
                    .general.b.autominl2 configure -state normal
                } else {
                    .general.b.automine configure -state disabled
                    .general.b.autominl1 configure -state disabled
                    .general.b.autominl2 configure -state disabled
                }
             }
        set state [expr {$param(win_prop) == 2 ? {normal} : {disabled}}]
        label .general.b.autominl1 -text [set s($lang)(after)] -font lfont \
            -state $state
        entry .general.b.automine -width 5 -textvariable param(autominDelay) \
            -font lfont -justify right -state $state
        label .general.b.autominl2 -text [set s($lang)(ms)] -font lfont \
            -state $state

        # Raise window when search done
        checkbutton .general.b.raise -text [set s($lang)(raise)] -font lfont \
            -variable param(raise)

        # Highlight text line when mouse over
        checkbutton .general.b.hilite -text [set s($lang)(hilite)] -font lfont \
            -variable param(hilite)

        # Autosave options
        checkbutton .general.b.as -text [set s($lang)(autosave)] -font lfont \
            -variable param(autosave)

        grid .general.b.hl -in .general.b -row 0 -column 0 -columnspan 2 \
            -sticky w -padx 4 -pady 4
        grid .general.b.he -in .general.b -row 0 -column 2 \
            -sticky e -padx 4 -pady 4
        grid .general.b.help -in .general.b -row 1 -column 0 \
            -sticky w -padx 4 -pady 4
        grid .general.b.l1 -in .general.b -row 1 -column 1 \
            -sticky w -padx 4 -pady 4
        grid .general.b.e -in .general.b -row 1 -column 2 \
            -sticky e -padx 4 -pady 4
        grid .general.b.l2 -in .general.b -row 1 -column 3 \
            -sticky w -padx 4 -pady 4
        grid .general.b.autosearch -in .general.b -row 2 -column 0 \
            -sticky w -padx 4 -pady 4
        grid .general.b.autosearchl1 -in .general.b -row 2 -column 1 \
            -sticky w -padx 4 -pady 4
        grid .general.b.autosearche -in .general.b -row 2 -column 2 \
            -sticky e -padx 4 -pady 4
        grid .general.b.autosearchl2 -in .general.b -row 2 -column 3 \
            -sticky w -padx 4 -pady 4
        grid .general.b.automin -in .general.b -row 3 -column 0 \
            -sticky w -padx 4 -pady 4
        grid .general.b.autominl1 -in .general.b -row 3 -column 1 \
            -sticky w -padx 4 -pady 4
        grid .general.b.automine -in .general.b -row 3 -column 2 \
            -sticky e -padx 4 -pady 4
        grid .general.b.autominl2 -in .general.b -row 3 -column 3 \
            -sticky w -padx 4 -pady 4
        grid .general.b.raise -in .general.b -row 4 -column 0 -columnspan 3 \
            -sticky w -padx 4 -pady 4
        grid .general.b.hilite -in .general.b -row 5 -column 0 -columnspan 3 \
            -sticky w -padx 4 -pady 4
        grid .general.b.as -in .general.b -row 6 -column 0 -columnspan 3 \
            -sticky w -padx 4 -pady 4

    } else {
        wm deiconify .general
        raise .general
    }
}

proc selectColor {w color name} {
    global s gparam 

    debug 2 "selectColor $color $name"
    set lang $gparam(lang)
    grab $w
    set color [tk_chooseColor -parent $w -title "[set s($lang)(color)] [set s($lang)($name)]" \
        -initialcolor $color]
    grab release $w
    if [string compare $color ""] {
        return $color
    }
}

# Save options 
proc saveOptions {} {
    global opts pinfo
    global param gparam
    global pinfo env s searchmeth searchmpos

    debug 1 "saveOptions"
    if {$gparam(noconf) == 1} {
        return
    }
    set lang $gparam(lang)
    if {[file readable $param(rcfile)] &&
        ![file isfile $param(rcfile)]} {
       errorBox "$param(rcfile) isn't a regular file!"
       return
    }
    set err [catch "set fd \[open $param(rcfile) w\]"]
    if $err {
        errorBox "Couldn't open $param(rcfile) for writing!"
        return
    }
    puts $fd "# Options for $pinfo(pname) - do not edit!"
    puts $fd "# General options"
    puts $fd "set ding_version {$pinfo(version)}"
    puts $fd "set param(autosave) {$param(autosave)}"
    puts $fd "set param(hilite) {$param(hilite)}"
    puts $fd "set param(raise) {$param(raise)}"
    puts $fd "set gparam(lang) {$lang}"
    puts $fd "set param(showBalloons) {$param(showBalloons)}"
    puts $fd "set param(balloonDelay) {$param(balloonDelay)}"
    puts $fd "set param(autosearch) {$param(autosearch)}"
    puts $fd "set param(autosearchDelay) {$param(autosearchDelay)}"
    # puts $fd "set param(automin) {$param(automin)}"
    puts $fd "set param(autominDelay) {$param(autominDelay)}"
    puts $fd "set param(params_as_menu) {$param(params_as_menu)}"
    puts $fd "set param(show_menu) {$param(show_menu)}"
    puts $fd "set param(umlaut_buttons) {$param(umlaut_buttons)}"
    puts $fd "set param(show_result) {$param(show_result)}"
    puts $fd "set param(show_status) {$param(show_status)}"
    puts $fd "set param(fcolor) {$param(fcolor)}"
    puts $fd "set param(bcolor) {$param(bcolor)}"
    puts $fd "set param(lfont) {$param(lfont)}"
    puts $fd "set param(bfont) {$param(bfont)}"
    puts $fd "set param(sfont) {$param(sfont)}"
    puts $fd "set param(tfont) {$param(tfont)}"
    puts $fd "set param(ifont) {$param(ifont)}"
    puts $fd "set param(maxhistory) {$param(maxhistory)}"
    puts $fd "set param(width) {$param(width)}"
    puts $fd "set param(height) {$param(height)}"
    puts $fd "set param(search_prop) {$param(search_prop)}"
    puts $fd "set param(win_prop) {$param(win_prop)}"

    puts $fd "set opts(word) {$opts(word)}"
    puts $fd "set opts(case) {$opts(case)}"
    puts $fd "set opts(errors) {$opts(errors)}"
    puts $fd "set opts(regex) {$opts(regex)}"

    puts $fd "\n# Dictionaries and search methods"
    set n 0
    set so ""
    foreach i $searchmpos {
        set so "$so $n"
        incr n
    }
    puts $fd "set searchmpos {$so}"

    set n 0
    foreach i $searchmpos {
        puts $fd "set searchmeth($n,name) {$searchmeth($i,name)}"
        puts $fd "set searchmeth($n,type) {$searchmeth($i,type)}"
        puts $fd "set searchmeth($n,dictfile) {$searchmeth($i,dictfile)}"
        puts $fd "set searchmeth($n,separator) {$searchmeth($i,separator)}"
        puts $fd "set searchmeth($n,language1) {$searchmeth($i,language1)}"
        puts $fd "set searchmeth($n,language2) {$searchmeth($i,language2)}"
        puts $fd "set searchmeth($n,grepcmd) {$searchmeth($i,grepcmd)}"
        puts $fd "set searchmeth($n,grepopts) {$searchmeth($i,grepopts)}"
        puts $fd "set searchmeth($n,maxlength) {$searchmeth($i,maxlength)}"
        puts $fd "set searchmeth($n,maxresults) {$searchmeth($i,maxresults)}"
        puts $fd "set searchmeth($n,minlength) {$searchmeth($i,minlength)}"
        puts $fd "set searchmeth($n,shapedresult) {$searchmeth($i,shapedresult)}"
        puts $fd "set searchmeth($n,foldedresult) {$searchmeth($i,foldedresult)}"
        incr n
    }

    catch {close $fd}
    .statusBar.lab configure -foreground $param(fcolor) -text "[set s($lang)(saveopts)] ok"
}

# History function
proc history {where} {
    global curhistory inshistory history_query history_result history_pos
    global param gparam s

    debug 1 "history $where"
    set lang $gparam(lang)
    set len [array size history_result]

    if ![string compare $where "back"] { # back
        if {$curhistory == 0} {
            set curhistory $inshistory
        }
        debug 8 "history: back: max $param(maxhistory) cur $curhistory ins $inshistory len $len"
        if {($curhistory <= 0) ||
            ($curhistory == 1 && $len < $param(maxhistory)) ||
            ($curhistory == 1 && $inshistory == $param(maxhistory)) ||
            ($curhistory == [expr $inshistory + 1])} {
                # no more history entries
                .statusBar.lab config -foreground $param(fcolor) \
                    -text [set s($lang)(noback)]
                return
        }
        # mark the current scroll position
        #set history_pos($curhistory) [lindex [.result.text yview] 0]
        set history_pos($curhistory) [.result.text index @0,0]
        if {$curhistory == 1} {
            set curhistory $param(maxhistory)
        } else {
            set curhistory [expr $curhistory - 1]
        }
        display $curhistory "" 2 ""
        if {($curhistory == 1 && ($len < $param(maxhistory) || $inshistory == $param(maxhistory))) || 
            ($inshistory == [expr $curhistory - 1])} {
            .search.s.back configure -state disabled
            .popup entryconfigure 0 -state disabled
        }
        .search.s.forw configure -state normal
        .popup entryconfigure 1 -state normal
    } else {            # forward
        debug 8 "history: forw: max $param(maxhistory) cur $curhistory ins $inshistory len $len"
        if {($curhistory <= 0) || ($len < $curhistory) ||
             ($len == $curhistory && $len < $param(maxhistory)) ||
             ($curhistory == $inshistory)} {
                # no more history entries
                .statusBar.lab config -foreground $param(fcolor) \
                    -text [set s($lang)(noforw)]
                return
        }
        # mark the current scroll position
        #set history_pos($curhistory) [lindex [.result.text yview] 0]
        set history_pos($curhistory) [.result.text index @0,0]
        if {$curhistory == $param(maxhistory)} {
            set curhistory 1
        } else {
            incr curhistory
        }
        display $curhistory "" 2 ""
        if {($curhistory >= $param(maxhistory) && $param(maxhistory) < $len) || 
            $curhistory == $inshistory} {
            .search.s.forw configure -state disabled
            .popup entryconfigure 1 -state disabled
        }
        .search.s.back configure -state normal
        .popup entryconfigure 0 -state normal
    }
}

proc sendMail {} {
    global param gparam pinfo s

    debug 1 "sendMail"
    set lang $gparam(lang)
    variable subject "$pinfo(pname) $pinfo(version): "
    variable nf $param(noticefile)

    if {! $param(isunix)} {
        # don't know how to send mail on Non-Unix ...
        tk_messageBox -icon error -type ok -parent . -message \
                    "[set s($lang)(nomail)] $pinfo(author)"
        return
    }

    if ![winfo exists .mail] {
        toplevel .mail
        wm group .mail .
        wm title .mail "[set s($lang)(mailtitle)] $pinfo(author)"
        wm resizable .mail 0 0
        placeWin .mail 50

        frame .mail.buttons
        button .mail.buttons.ok -text [set s($lang)(send)] -width 15 -command {
            set text [.mail.t.text get 1.0 end]
            if {[string length $text] <= 3} {
	        tk_messageBox -icon warning -type ok -parent .mail -message \
                    [set s($lang)(notext)]
        
                return
            }
            catch {set fd [open "|mail -s \"$subject\" $pinfo(authormail)" w]} em
            if ![info exists fd] {
                catch {set fd [open "|mail $pinfo(authormail)" w]} em
            }
            if ![info exists fd] {
                tk_messageBox -icon error -type ok -parent .mail -message \
                    [set s($lang)(notext)]
            } else {
                puts -nonewline $fd $text
                close $fd
                .statusBar.lab config -foreground $param(fcolor) \
                    -text "[set s($lang)(send)] ok."
            }
            destroy .mail
        }
        button .mail.buttons.cancel -text [set s($lang)(cancel)] -width 15 \
            -command {destroy .mail}
        pack .mail.buttons -side bottom -expand 1 -padx 8 -pady 8
        pack .mail.buttons.ok .mail.buttons.cancel -side left -padx 8

        frame .mail.s
        label .mail.s.label -text "Subject: " -font bfont
        entry .mail.s.subject -bg $param(shadedcolor) -textvariable subject \
            -relief flat -font lfont

        label .mail.s.flabel -text "[set s($lang)(file)]: " -font bfont
        entry .mail.s.fname -bg $param(shadedcolor) -font lfont \
            -textvariable nf -relief flat
        variable types {
            {"Text files" {.txt .vok .dic}}
            {"All files" *}
        }
        button .mail.s.fb -font lfont -text "[set s($lang)(attachnotice)] ..." \
            -relief raised -command {
                if [string compare $nf ""] {
                    set err [catch "set fd \[open $nf r\]"]
                    if {! $err} {
                        .mail.t.text insert end [read $fd]
                        close $fd
                    }
                }
            }
        pack .mail.s -side top -fill x -expand 1 -padx 8 -pady 8
        grid columnconfig .mail.s 1 -weight 1
        grid .mail.s.label -row 0 -column 0 -sticky e
        grid .mail.s.subject -row 0 -column 1 -sticky news
        # grid x -in .mail.s 
        grid .mail.s.flabel -row 1 -column 0 -sticky e
        grid .mail.s.fname -row 1 -column 1 -sticky news
        grid .mail.s.fb -in .mail.s -row 1 -column 2 -sticky w -padx 4

        # pack .mail.s.label -side left
        # pack .mail.s.subject -side left -fill x -expand 1
        
        frame .mail.t
        text .mail.t.text -wrap word -width 70 -height 15 \
            -relief flat -bg $param(shadedcolor) \
            -yscrollcommand ".mail.t.yscroll set"

        scrollbar .mail.t.yscroll -orient vertical \
                -command { .mail.t.text yview }
        if {$param(isunix)} {          # I like smaller scrollbars
            .mail.t.yscroll configure -width 10 -bd 1
        }
        pack .mail.t -fill x -expand 1 -padx 8 -pady 8
        pack .mail.t.text .mail.t.yscroll -side left -fill both -expand 1

    } else {
        wm deiconify .mail
        raise .mail 
    }
}

proc notice {file} {
    global param gparam s

    debug 1 "notice file"
    set lang $gparam(lang)

    if ![winfo exists .notice] {
        toplevel .notice
        wm group .notice .
        wm title .notice "[set s($lang)(notice)]"
        wm resizable .notice 0 0
        placeWin .notice 50

        variable nf $file

        frame .notice.buttons
        button .notice.buttons.ok -text [set s($lang)(save)] -width 15 -command {
            set text [.notice.t.text get 1.0 end]
            if {[string length $text] <= 0} {
	        tk_messageBox -icon warning -type ok -parent .notice -message \
                    [set s($lang)(notext)]
                return
            }
            set err [catch "set fd \[open $nf w\]"]
            if $err {
	            tk_messageBox -icon error -type ok -parent . -message \
        	            "Couldn't open $nf for writing!"
                return
            } else {
                puts -nonewline $fd $text
                close $fd
            }
            set $param(noticefile) $nf
            .statusBar.lab config -foreground $param(fcolor) \
                -text "[set s($lang)(save)] ok."
            destroy .notice
        }
        button .notice.buttons.cancel -text [set s($lang)(cancel)] -width 15 \
            -command {destroy .notice}
        pack .notice.buttons -side bottom -expand 1 -padx 8 -pady 8
        pack .notice.buttons.ok .notice.buttons.cancel -side left -padx 8

        frame .notice.f
        label .notice.f.label -text "[set s($lang)(file)]:"
        entry .notice.f.name -bg $param(shadedcolor) -font lfont \
            -textvariable nf -relief flat
        variable types {
            {"Text files" {.txt .vok .dic}}
            {"All files" *}
        }

        button .notice.f.b -font lfont -text "Browse ..." \
            -command {
                set f [tk_getSaveFile -initialdir [file dirname $nf] \
                    -filetypes $types -parent .notice]
                if [string compare $f ""] {
                    set nf $f
                }
            }
 
        pack .notice.f -side top -fill x -expand 1 -padx 8 -pady 8
        pack .notice.f.label -side left
        pack .notice.f.name -side left -fill x -expand 1
        pack .notice.f.b -side left
        frame .notice.t
        text .notice.t.text -wrap word -width 70 -height 15 \
            -relief flat -bg $param(shadedcolor) \
            -yscrollcommand ".notice.t.yscroll set"

        scrollbar .notice.t.yscroll -orient vertical \
                -command { .notice.t.text yview }
        if {$param(isunix)} {          # I like smaller scrollbars
            .notice.t.yscroll configure -width 10 -bd 1
        }
        pack .notice.t -fill x -expand 1 -padx 8 -pady 8
        pack .notice.t.text .notice.t.yscroll -side left -fill both -expand 1

        set err [catch "set fd \[open $nf r\]"]
        if {! $err} {
            .notice.t.text insert end [read $fd]
            close $fd
        }
    } else {
        wm deiconify .notice
        raise .notice 
    }
    focus .notice.t.text
}

proc startNew {} {
    global param gparam argv0

    set prog "$argv0 --noconf"
    debug 1 "new win: $prog"
    if [catch {exec $argv0 --noconf &} err] {
        .statusBar.lab config -foreground $param(errcolor) -text \
            "Error starting $prog: $err"
    } else {
        .statusBar.lab config -foreground $param(fcolor) -text "$prog started"
    }
}



# Invoking browsers
# http://mini.net/cgi-bin/wikit/InvokingBrowsers

proc urlOpen {url} {
    global param
    switch $::tcl_platform(platform) {
       "unix" {
            set asciibrowser 0
            if {0 == [info exists ::env(BROWSER)]} {
               if {[string length [auto_execok firefox]] } {
                  set ::env(BROWSER) [auto_execok firefox]
               } elseif {[string length [auto_execok mozilla]] } {
                  set ::env(BROWSER) [auto_execok mozilla]
               } elseif {[string length [auto_execok opera]] } {
                  set ::env(BROWSER) [auto_execok opera]
               } elseif {[string length [auto_execok galeon]] } {
                  set ::env(BROWSER) [auto_execok galeon]
               } elseif {[string length [auto_execok konqueror]] } {
                  set ::env(BROWSER) [auto_execok konqueror]
               } elseif {[string length [auto_execok netscape]] } {
                  set ::env(BROWSER) [auto_execok netscape]
               } elseif {[info exists ::env(NETSCAPE)]} {
                  # Some of us use this envvar instead... - DKF
                  set ::env(BROWSER) $::env(NETSCAPE)
               } elseif {[string length [auto_execok x-terminal-emulator]]} {
                  set asciibrowser 1
                  if {[string length [auto_execok w3m]]} {
                     set ::env(BROWSER) [auto_execok w3m]
                  } elseif {[string length [auto_execok links]]} {
                     set ::env(BROWSER) [auto_execok links]
                  } elseif {[string length [auto_execok lynx]]} {
                     set ::env(BROWSER) [auto_execok lynx]
                  }
               }
            }
            if { [info exists ::env(BROWSER)] } {
                if {$asciibrowser} {
                    debug 4 "Invoking [auto_execok x-terminal-emulator] -c $::env(BROWSER) $url"
                    .statusBar.lab config -foreground $param(fcolor) \
                      -text "[auto_execok x-terminal-emulator] -c $::env(BROWSER) $url ..."
                    catch { exec [auto_execok x-terminal-emulator] -c $::env(BROWSER) $url &}
                } else {
                    debug 4 "Invoking $::env(BROWSER) $url"
                    .statusBar.lab config -foreground $param(fcolor) \
                       -text "$::env(BROWSER) $url ..."
                    catch {exec $::env(BROWSER) $url &}
                }
            } else {
                error "No web browser found\n"
            }
         }
      "windows" {
          if {$::tcl_platform(os) == "Windows NT"} {
             set rc [catch {exec $::env(COMSPEC) /c start $url &} emsg]
          } else {
             # Windows 95/98
             set rc [catch {exec start $url} emsg]
          }
          if {$rc} {
             error "Error displaying $url in browser\n$emsg"
          }
        }
      "macintosh" {
          # AppleScript should be able to provide the default browser,
          # but I'm not enough of an AppleScript hacker to figure out.
          # Help!
          if {0 == [info exists ::env(BROWSER)]} {
             error "Couldn't find a usable browser.  Set env(BROWSER) in your application's preferences file."
          }
          if {[catch {
             AppleScript execute "tell application \"$::env(BROWSER)\"
             open url \"$url\"
             end tell
             "} emsg]
          } then {
             error "Error displaying $url in browser\n$emsg"
          }
       }
    } ;## end of switch
}


